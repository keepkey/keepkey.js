/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var google_protobuf_descriptor_pb = require('google-protobuf/google/protobuf/descriptor_pb.js');
var exchange_pb = require('./exchange_pb.js');
goog.exportSymbol('proto.ButtonRequestType', null, global);
goog.exportSymbol('proto.CoinType', null, global);
goog.exportSymbol('proto.ExchangeType', null, global);
goog.exportSymbol('proto.FailureType', null, global);
goog.exportSymbol('proto.HDNodePathType', null, global);
goog.exportSymbol('proto.HDNodeType', null, global);
goog.exportSymbol('proto.IdentityType', null, global);
goog.exportSymbol('proto.InputScriptType', null, global);
goog.exportSymbol('proto.MultisigRedeemScriptType', null, global);
goog.exportSymbol('proto.OutputAddressType', null, global);
goog.exportSymbol('proto.OutputScriptType', null, global);
goog.exportSymbol('proto.PinMatrixRequestType', null, global);
goog.exportSymbol('proto.PolicyType', null, global);
goog.exportSymbol('proto.RawTransactionType', null, global);
goog.exportSymbol('proto.RequestType', null, global);
goog.exportSymbol('proto.TransactionType', null, global);
goog.exportSymbol('proto.TxInputType', null, global);
goog.exportSymbol('proto.TxOutputBinType', null, global);
goog.exportSymbol('proto.TxOutputType', null, global);
goog.exportSymbol('proto.TxRequestDetailsType', null, global);
goog.exportSymbol('proto.TxRequestSerializedType', null, global);
goog.exportSymbol('proto.wireDebugIn', null, global);
goog.exportSymbol('proto.wireDebugOut', null, global);
goog.exportSymbol('proto.wireIn', null, global);
goog.exportSymbol('proto.wireOut', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.HDNodeType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.HDNodeType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.HDNodeType.displayName = 'proto.HDNodeType';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.HDNodeType.prototype.toObject = function(opt_includeInstance) {
  return proto.HDNodeType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.HDNodeType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.HDNodeType.toObject = function(includeInstance, msg) {
  var f, obj = {
    depth: jspb.Message.getField(msg, 1),
    fingerprint: jspb.Message.getField(msg, 2),
    childNum: jspb.Message.getField(msg, 3),
    chainCode: msg.getChainCode_asB64(),
    privateKey: msg.getPrivateKey_asB64(),
    publicKey: msg.getPublicKey_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.HDNodeType}
 */
proto.HDNodeType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.HDNodeType;
  return proto.HDNodeType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.HDNodeType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.HDNodeType}
 */
proto.HDNodeType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDepth(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setFingerprint(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setChildNum(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setChainCode(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrivateKey(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPublicKey(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.HDNodeType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.HDNodeType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.HDNodeType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.HDNodeType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeBytes(
      6,
      f
    );
  }
};


/**
 * required uint32 depth = 1;
 * @return {number}
 */
proto.HDNodeType.prototype.getDepth = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.HDNodeType.prototype.setDepth = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.HDNodeType.prototype.clearDepth = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.HDNodeType.prototype.hasDepth = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required uint32 fingerprint = 2;
 * @return {number}
 */
proto.HDNodeType.prototype.getFingerprint = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.HDNodeType.prototype.setFingerprint = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.HDNodeType.prototype.clearFingerprint = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.HDNodeType.prototype.hasFingerprint = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * required uint32 child_num = 3;
 * @return {number}
 */
proto.HDNodeType.prototype.getChildNum = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.HDNodeType.prototype.setChildNum = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.HDNodeType.prototype.clearChildNum = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.HDNodeType.prototype.hasChildNum = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * required bytes chain_code = 4;
 * @return {!(string|Uint8Array)}
 */
proto.HDNodeType.prototype.getChainCode = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * required bytes chain_code = 4;
 * This is a type-conversion wrapper around `getChainCode()`
 * @return {string}
 */
proto.HDNodeType.prototype.getChainCode_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getChainCode()));
};


/**
 * required bytes chain_code = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getChainCode()`
 * @return {!Uint8Array}
 */
proto.HDNodeType.prototype.getChainCode_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getChainCode()));
};


/** @param {!(string|Uint8Array)} value */
proto.HDNodeType.prototype.setChainCode = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.HDNodeType.prototype.clearChainCode = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.HDNodeType.prototype.hasChainCode = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional bytes private_key = 5;
 * @return {!(string|Uint8Array)}
 */
proto.HDNodeType.prototype.getPrivateKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes private_key = 5;
 * This is a type-conversion wrapper around `getPrivateKey()`
 * @return {string}
 */
proto.HDNodeType.prototype.getPrivateKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrivateKey()));
};


/**
 * optional bytes private_key = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrivateKey()`
 * @return {!Uint8Array}
 */
proto.HDNodeType.prototype.getPrivateKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrivateKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.HDNodeType.prototype.setPrivateKey = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.HDNodeType.prototype.clearPrivateKey = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.HDNodeType.prototype.hasPrivateKey = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional bytes public_key = 6;
 * @return {!(string|Uint8Array)}
 */
proto.HDNodeType.prototype.getPublicKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * optional bytes public_key = 6;
 * This is a type-conversion wrapper around `getPublicKey()`
 * @return {string}
 */
proto.HDNodeType.prototype.getPublicKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPublicKey()));
};


/**
 * optional bytes public_key = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPublicKey()`
 * @return {!Uint8Array}
 */
proto.HDNodeType.prototype.getPublicKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPublicKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.HDNodeType.prototype.setPublicKey = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.HDNodeType.prototype.clearPublicKey = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.HDNodeType.prototype.hasPublicKey = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.HDNodePathType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.HDNodePathType.repeatedFields_, null);
};
goog.inherits(proto.HDNodePathType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.HDNodePathType.displayName = 'proto.HDNodePathType';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.HDNodePathType.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.HDNodePathType.prototype.toObject = function(opt_includeInstance) {
  return proto.HDNodePathType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.HDNodePathType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.HDNodePathType.toObject = function(includeInstance, msg) {
  var f, obj = {
    node: (f = msg.getNode()) && proto.HDNodeType.toObject(includeInstance, f),
    addressNList: jspb.Message.getRepeatedField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.HDNodePathType}
 */
proto.HDNodePathType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.HDNodePathType;
  return proto.HDNodePathType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.HDNodePathType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.HDNodePathType}
 */
proto.HDNodePathType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.HDNodeType;
      reader.readMessage(value,proto.HDNodeType.deserializeBinaryFromReader);
      msg.setNode(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addAddressN(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.HDNodePathType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.HDNodePathType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.HDNodePathType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.HDNodePathType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNode();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      proto.HDNodeType.serializeBinaryToWriter
    );
  }
  f = message.getAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      2,
      f
    );
  }
};


/**
 * required HDNodeType node = 1;
 * @return {!proto.HDNodeType}
 */
proto.HDNodePathType.prototype.getNode = function() {
  return /** @type{!proto.HDNodeType} */ (
    jspb.Message.getWrapperField(this, proto.HDNodeType, 1, 1));
};


/** @param {!proto.HDNodeType} value */
proto.HDNodePathType.prototype.setNode = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.HDNodePathType.prototype.clearNode = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.HDNodePathType.prototype.hasNode = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated uint32 address_n = 2;
 * @return {!Array<number>}
 */
proto.HDNodePathType.prototype.getAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 2));
};


/** @param {!Array<number>} value */
proto.HDNodePathType.prototype.setAddressNList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.HDNodePathType.prototype.addAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


proto.HDNodePathType.prototype.clearAddressNList = function() {
  this.setAddressNList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CoinType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CoinType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.CoinType.displayName = 'proto.CoinType';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CoinType.prototype.toObject = function(opt_includeInstance) {
  return proto.CoinType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CoinType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CoinType.toObject = function(includeInstance, msg) {
  var f, obj = {
    coinName: jspb.Message.getField(msg, 1),
    coinShortcut: jspb.Message.getField(msg, 2),
    addressType: jspb.Message.getFieldWithDefault(msg, 3, 0),
    maxfeeKb: jspb.Message.getField(msg, 4),
    addressTypeP2sh: jspb.Message.getFieldWithDefault(msg, 5, 5),
    addressTypeP2wpkh: jspb.Message.getFieldWithDefault(msg, 6, 6),
    addressTypeP2wsh: jspb.Message.getFieldWithDefault(msg, 7, 10),
    signedMessageHeader: jspb.Message.getField(msg, 8),
    bip44AccountPath: jspb.Message.getField(msg, 9),
    forkid: jspb.Message.getField(msg, 12),
    decimals: jspb.Message.getField(msg, 13),
    contractAddress: msg.getContractAddress_asB64(),
    gasLimit: msg.getGasLimit_asB64(),
    xpubMagic: jspb.Message.getFieldWithDefault(msg, 16, 76067358),
    xprvMagic: jspb.Message.getFieldWithDefault(msg, 17, 76066276),
    segwit: jspb.Message.getField(msg, 18),
    forceBip143: jspb.Message.getField(msg, 19),
    curveName: jspb.Message.getField(msg, 20),
    cashaddrPrefix: jspb.Message.getField(msg, 21),
    bech32Prefix: jspb.Message.getField(msg, 22),
    decred: jspb.Message.getField(msg, 23),
    versionGroupId: jspb.Message.getField(msg, 24),
    xpubMagicSegwitP2sh: jspb.Message.getField(msg, 25),
    xpubMagicSegwitNative: jspb.Message.getField(msg, 26)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CoinType}
 */
proto.CoinType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CoinType;
  return proto.CoinType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CoinType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CoinType}
 */
proto.CoinType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setCoinName(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setCoinShortcut(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAddressType(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setMaxfeeKb(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAddressTypeP2sh(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAddressTypeP2wpkh(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAddressTypeP2wsh(value);
      break;
    case 8:
      var value = /** @type {string} */ (reader.readString());
      msg.setSignedMessageHeader(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setBip44AccountPath(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setForkid(value);
      break;
    case 13:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDecimals(value);
      break;
    case 14:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setContractAddress(value);
      break;
    case 15:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setGasLimit(value);
      break;
    case 16:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setXpubMagic(value);
      break;
    case 17:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setXprvMagic(value);
      break;
    case 18:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSegwit(value);
      break;
    case 19:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setForceBip143(value);
      break;
    case 20:
      var value = /** @type {string} */ (reader.readString());
      msg.setCurveName(value);
      break;
    case 21:
      var value = /** @type {string} */ (reader.readString());
      msg.setCashaddrPrefix(value);
      break;
    case 22:
      var value = /** @type {string} */ (reader.readString());
      msg.setBech32Prefix(value);
      break;
    case 23:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDecred(value);
      break;
    case 24:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVersionGroupId(value);
      break;
    case 25:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setXpubMagicSegwitP2sh(value);
      break;
    case 26:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setXpubMagicSegwitNative(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CoinType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CoinType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CoinType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CoinType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeUint64(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeUint32(
      7,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeString(
      8,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeUint32(
      9,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 12));
  if (f != null) {
    writer.writeUint32(
      12,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 13));
  if (f != null) {
    writer.writeUint32(
      13,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 14));
  if (f != null) {
    writer.writeBytes(
      14,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 15));
  if (f != null) {
    writer.writeBytes(
      15,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 16));
  if (f != null) {
    writer.writeUint32(
      16,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 17));
  if (f != null) {
    writer.writeUint32(
      17,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 18));
  if (f != null) {
    writer.writeBool(
      18,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 19));
  if (f != null) {
    writer.writeBool(
      19,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 20));
  if (f != null) {
    writer.writeString(
      20,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 21));
  if (f != null) {
    writer.writeString(
      21,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 22));
  if (f != null) {
    writer.writeString(
      22,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 23));
  if (f != null) {
    writer.writeBool(
      23,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 24));
  if (f != null) {
    writer.writeUint32(
      24,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 25));
  if (f != null) {
    writer.writeUint32(
      25,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 26));
  if (f != null) {
    writer.writeUint32(
      26,
      f
    );
  }
};


/**
 * optional string coin_name = 1;
 * @return {string}
 */
proto.CoinType.prototype.getCoinName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.CoinType.prototype.setCoinName = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.CoinType.prototype.clearCoinName = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasCoinName = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string coin_shortcut = 2;
 * @return {string}
 */
proto.CoinType.prototype.getCoinShortcut = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.CoinType.prototype.setCoinShortcut = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.CoinType.prototype.clearCoinShortcut = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasCoinShortcut = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint32 address_type = 3;
 * @return {number}
 */
proto.CoinType.prototype.getAddressType = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.CoinType.prototype.setAddressType = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.CoinType.prototype.clearAddressType = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasAddressType = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional uint64 maxfee_kb = 4;
 * @return {number}
 */
proto.CoinType.prototype.getMaxfeeKb = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.CoinType.prototype.setMaxfeeKb = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.CoinType.prototype.clearMaxfeeKb = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasMaxfeeKb = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional uint32 address_type_p2sh = 5;
 * @return {number}
 */
proto.CoinType.prototype.getAddressTypeP2sh = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 5));
};


/** @param {number} value */
proto.CoinType.prototype.setAddressTypeP2sh = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.CoinType.prototype.clearAddressTypeP2sh = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasAddressTypeP2sh = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional uint32 address_type_p2wpkh = 6;
 * @return {number}
 */
proto.CoinType.prototype.getAddressTypeP2wpkh = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 6));
};


/** @param {number} value */
proto.CoinType.prototype.setAddressTypeP2wpkh = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.CoinType.prototype.clearAddressTypeP2wpkh = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasAddressTypeP2wpkh = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional uint32 address_type_p2wsh = 7;
 * @return {number}
 */
proto.CoinType.prototype.getAddressTypeP2wsh = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 10));
};


/** @param {number} value */
proto.CoinType.prototype.setAddressTypeP2wsh = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.CoinType.prototype.clearAddressTypeP2wsh = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasAddressTypeP2wsh = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional string signed_message_header = 8;
 * @return {string}
 */
proto.CoinType.prototype.getSignedMessageHeader = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/** @param {string} value */
proto.CoinType.prototype.setSignedMessageHeader = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.CoinType.prototype.clearSignedMessageHeader = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasSignedMessageHeader = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional uint32 bip44_account_path = 9;
 * @return {number}
 */
proto.CoinType.prototype.getBip44AccountPath = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.CoinType.prototype.setBip44AccountPath = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.CoinType.prototype.clearBip44AccountPath = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasBip44AccountPath = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional uint32 forkid = 12;
 * @return {number}
 */
proto.CoinType.prototype.getForkid = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 12, 0));
};


/** @param {number} value */
proto.CoinType.prototype.setForkid = function(value) {
  jspb.Message.setField(this, 12, value);
};


proto.CoinType.prototype.clearForkid = function() {
  jspb.Message.setField(this, 12, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasForkid = function() {
  return jspb.Message.getField(this, 12) != null;
};


/**
 * optional uint32 decimals = 13;
 * @return {number}
 */
proto.CoinType.prototype.getDecimals = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 13, 0));
};


/** @param {number} value */
proto.CoinType.prototype.setDecimals = function(value) {
  jspb.Message.setField(this, 13, value);
};


proto.CoinType.prototype.clearDecimals = function() {
  jspb.Message.setField(this, 13, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasDecimals = function() {
  return jspb.Message.getField(this, 13) != null;
};


/**
 * optional bytes contract_address = 14;
 * @return {!(string|Uint8Array)}
 */
proto.CoinType.prototype.getContractAddress = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 14, ""));
};


/**
 * optional bytes contract_address = 14;
 * This is a type-conversion wrapper around `getContractAddress()`
 * @return {string}
 */
proto.CoinType.prototype.getContractAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getContractAddress()));
};


/**
 * optional bytes contract_address = 14;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getContractAddress()`
 * @return {!Uint8Array}
 */
proto.CoinType.prototype.getContractAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getContractAddress()));
};


/** @param {!(string|Uint8Array)} value */
proto.CoinType.prototype.setContractAddress = function(value) {
  jspb.Message.setField(this, 14, value);
};


proto.CoinType.prototype.clearContractAddress = function() {
  jspb.Message.setField(this, 14, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasContractAddress = function() {
  return jspb.Message.getField(this, 14) != null;
};


/**
 * optional bytes gas_limit = 15;
 * @return {!(string|Uint8Array)}
 */
proto.CoinType.prototype.getGasLimit = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 15, ""));
};


/**
 * optional bytes gas_limit = 15;
 * This is a type-conversion wrapper around `getGasLimit()`
 * @return {string}
 */
proto.CoinType.prototype.getGasLimit_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getGasLimit()));
};


/**
 * optional bytes gas_limit = 15;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getGasLimit()`
 * @return {!Uint8Array}
 */
proto.CoinType.prototype.getGasLimit_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getGasLimit()));
};


/** @param {!(string|Uint8Array)} value */
proto.CoinType.prototype.setGasLimit = function(value) {
  jspb.Message.setField(this, 15, value);
};


proto.CoinType.prototype.clearGasLimit = function() {
  jspb.Message.setField(this, 15, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasGasLimit = function() {
  return jspb.Message.getField(this, 15) != null;
};


/**
 * optional uint32 xpub_magic = 16;
 * @return {number}
 */
proto.CoinType.prototype.getXpubMagic = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 16, 76067358));
};


/** @param {number} value */
proto.CoinType.prototype.setXpubMagic = function(value) {
  jspb.Message.setField(this, 16, value);
};


proto.CoinType.prototype.clearXpubMagic = function() {
  jspb.Message.setField(this, 16, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasXpubMagic = function() {
  return jspb.Message.getField(this, 16) != null;
};


/**
 * optional uint32 xprv_magic = 17;
 * @return {number}
 */
proto.CoinType.prototype.getXprvMagic = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 17, 76066276));
};


/** @param {number} value */
proto.CoinType.prototype.setXprvMagic = function(value) {
  jspb.Message.setField(this, 17, value);
};


proto.CoinType.prototype.clearXprvMagic = function() {
  jspb.Message.setField(this, 17, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasXprvMagic = function() {
  return jspb.Message.getField(this, 17) != null;
};


/**
 * optional bool segwit = 18;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.CoinType.prototype.getSegwit = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 18, false));
};


/** @param {boolean} value */
proto.CoinType.prototype.setSegwit = function(value) {
  jspb.Message.setField(this, 18, value);
};


proto.CoinType.prototype.clearSegwit = function() {
  jspb.Message.setField(this, 18, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasSegwit = function() {
  return jspb.Message.getField(this, 18) != null;
};


/**
 * optional bool force_bip143 = 19;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.CoinType.prototype.getForceBip143 = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 19, false));
};


/** @param {boolean} value */
proto.CoinType.prototype.setForceBip143 = function(value) {
  jspb.Message.setField(this, 19, value);
};


proto.CoinType.prototype.clearForceBip143 = function() {
  jspb.Message.setField(this, 19, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasForceBip143 = function() {
  return jspb.Message.getField(this, 19) != null;
};


/**
 * optional string curve_name = 20;
 * @return {string}
 */
proto.CoinType.prototype.getCurveName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 20, ""));
};


/** @param {string} value */
proto.CoinType.prototype.setCurveName = function(value) {
  jspb.Message.setField(this, 20, value);
};


proto.CoinType.prototype.clearCurveName = function() {
  jspb.Message.setField(this, 20, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasCurveName = function() {
  return jspb.Message.getField(this, 20) != null;
};


/**
 * optional string cashaddr_prefix = 21;
 * @return {string}
 */
proto.CoinType.prototype.getCashaddrPrefix = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 21, ""));
};


/** @param {string} value */
proto.CoinType.prototype.setCashaddrPrefix = function(value) {
  jspb.Message.setField(this, 21, value);
};


proto.CoinType.prototype.clearCashaddrPrefix = function() {
  jspb.Message.setField(this, 21, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasCashaddrPrefix = function() {
  return jspb.Message.getField(this, 21) != null;
};


/**
 * optional string bech32_prefix = 22;
 * @return {string}
 */
proto.CoinType.prototype.getBech32Prefix = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 22, ""));
};


/** @param {string} value */
proto.CoinType.prototype.setBech32Prefix = function(value) {
  jspb.Message.setField(this, 22, value);
};


proto.CoinType.prototype.clearBech32Prefix = function() {
  jspb.Message.setField(this, 22, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasBech32Prefix = function() {
  return jspb.Message.getField(this, 22) != null;
};


/**
 * optional bool decred = 23;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.CoinType.prototype.getDecred = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 23, false));
};


/** @param {boolean} value */
proto.CoinType.prototype.setDecred = function(value) {
  jspb.Message.setField(this, 23, value);
};


proto.CoinType.prototype.clearDecred = function() {
  jspb.Message.setField(this, 23, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasDecred = function() {
  return jspb.Message.getField(this, 23) != null;
};


/**
 * optional uint32 version_group_id = 24;
 * @return {number}
 */
proto.CoinType.prototype.getVersionGroupId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 24, 0));
};


/** @param {number} value */
proto.CoinType.prototype.setVersionGroupId = function(value) {
  jspb.Message.setField(this, 24, value);
};


proto.CoinType.prototype.clearVersionGroupId = function() {
  jspb.Message.setField(this, 24, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasVersionGroupId = function() {
  return jspb.Message.getField(this, 24) != null;
};


/**
 * optional uint32 xpub_magic_segwit_p2sh = 25;
 * @return {number}
 */
proto.CoinType.prototype.getXpubMagicSegwitP2sh = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 25, 0));
};


/** @param {number} value */
proto.CoinType.prototype.setXpubMagicSegwitP2sh = function(value) {
  jspb.Message.setField(this, 25, value);
};


proto.CoinType.prototype.clearXpubMagicSegwitP2sh = function() {
  jspb.Message.setField(this, 25, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasXpubMagicSegwitP2sh = function() {
  return jspb.Message.getField(this, 25) != null;
};


/**
 * optional uint32 xpub_magic_segwit_native = 26;
 * @return {number}
 */
proto.CoinType.prototype.getXpubMagicSegwitNative = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 26, 0));
};


/** @param {number} value */
proto.CoinType.prototype.setXpubMagicSegwitNative = function(value) {
  jspb.Message.setField(this, 26, value);
};


proto.CoinType.prototype.clearXpubMagicSegwitNative = function() {
  jspb.Message.setField(this, 26, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinType.prototype.hasXpubMagicSegwitNative = function() {
  return jspb.Message.getField(this, 26) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.MultisigRedeemScriptType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.MultisigRedeemScriptType.repeatedFields_, null);
};
goog.inherits(proto.MultisigRedeemScriptType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.MultisigRedeemScriptType.displayName = 'proto.MultisigRedeemScriptType';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.MultisigRedeemScriptType.repeatedFields_ = [1,2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.MultisigRedeemScriptType.prototype.toObject = function(opt_includeInstance) {
  return proto.MultisigRedeemScriptType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.MultisigRedeemScriptType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.MultisigRedeemScriptType.toObject = function(includeInstance, msg) {
  var f, obj = {
    pubkeysList: jspb.Message.toObjectList(msg.getPubkeysList(),
    proto.HDNodePathType.toObject, includeInstance),
    signaturesList: msg.getSignaturesList_asB64(),
    m: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.MultisigRedeemScriptType}
 */
proto.MultisigRedeemScriptType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.MultisigRedeemScriptType;
  return proto.MultisigRedeemScriptType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.MultisigRedeemScriptType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.MultisigRedeemScriptType}
 */
proto.MultisigRedeemScriptType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new proto.HDNodePathType;
      reader.readMessage(value,proto.HDNodePathType.deserializeBinaryFromReader);
      msg.addPubkeys(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.addSignatures(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setM(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.MultisigRedeemScriptType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.MultisigRedeemScriptType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.MultisigRedeemScriptType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.MultisigRedeemScriptType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPubkeysList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      proto.HDNodePathType.serializeBinaryToWriter
    );
  }
  f = message.getSignaturesList_asU8();
  if (f.length > 0) {
    writer.writeRepeatedBytes(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * repeated HDNodePathType pubkeys = 1;
 * @return {!Array<!proto.HDNodePathType>}
 */
proto.MultisigRedeemScriptType.prototype.getPubkeysList = function() {
  return /** @type{!Array<!proto.HDNodePathType>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.HDNodePathType, 1));
};


/** @param {!Array<!proto.HDNodePathType>} value */
proto.MultisigRedeemScriptType.prototype.setPubkeysList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.HDNodePathType=} opt_value
 * @param {number=} opt_index
 * @return {!proto.HDNodePathType}
 */
proto.MultisigRedeemScriptType.prototype.addPubkeys = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.HDNodePathType, opt_index);
};


proto.MultisigRedeemScriptType.prototype.clearPubkeysList = function() {
  this.setPubkeysList([]);
};


/**
 * repeated bytes signatures = 2;
 * @return {!(Array<!Uint8Array>|Array<string>)}
 */
proto.MultisigRedeemScriptType.prototype.getSignaturesList = function() {
  return /** @type {!(Array<!Uint8Array>|Array<string>)} */ (jspb.Message.getRepeatedField(this, 2));
};


/**
 * repeated bytes signatures = 2;
 * This is a type-conversion wrapper around `getSignaturesList()`
 * @return {!Array<string>}
 */
proto.MultisigRedeemScriptType.prototype.getSignaturesList_asB64 = function() {
  return /** @type {!Array<string>} */ (jspb.Message.bytesListAsB64(
      this.getSignaturesList()));
};


/**
 * repeated bytes signatures = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignaturesList()`
 * @return {!Array<!Uint8Array>}
 */
proto.MultisigRedeemScriptType.prototype.getSignaturesList_asU8 = function() {
  return /** @type {!Array<!Uint8Array>} */ (jspb.Message.bytesListAsU8(
      this.getSignaturesList()));
};


/** @param {!(Array<!Uint8Array>|Array<string>)} value */
proto.MultisigRedeemScriptType.prototype.setSignaturesList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!(string|Uint8Array)} value
 * @param {number=} opt_index
 */
proto.MultisigRedeemScriptType.prototype.addSignatures = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


proto.MultisigRedeemScriptType.prototype.clearSignaturesList = function() {
  this.setSignaturesList([]);
};


/**
 * optional uint32 m = 3;
 * @return {number}
 */
proto.MultisigRedeemScriptType.prototype.getM = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.MultisigRedeemScriptType.prototype.setM = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.MultisigRedeemScriptType.prototype.clearM = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.MultisigRedeemScriptType.prototype.hasM = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TxInputType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.TxInputType.repeatedFields_, null);
};
goog.inherits(proto.TxInputType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.TxInputType.displayName = 'proto.TxInputType';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.TxInputType.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TxInputType.prototype.toObject = function(opt_includeInstance) {
  return proto.TxInputType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TxInputType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxInputType.toObject = function(includeInstance, msg) {
  var f, obj = {
    addressNList: jspb.Message.getRepeatedField(msg, 1),
    prevHash: msg.getPrevHash_asB64(),
    prevIndex: jspb.Message.getField(msg, 3),
    scriptSig: msg.getScriptSig_asB64(),
    sequence: jspb.Message.getFieldWithDefault(msg, 5, -1),
    scriptType: jspb.Message.getFieldWithDefault(msg, 6, 0),
    multisig: (f = msg.getMultisig()) && proto.MultisigRedeemScriptType.toObject(includeInstance, f),
    amount: jspb.Message.getField(msg, 8),
    decredTree: jspb.Message.getField(msg, 9),
    decredScriptVersion: jspb.Message.getField(msg, 10)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TxInputType}
 */
proto.TxInputType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TxInputType;
  return proto.TxInputType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TxInputType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TxInputType}
 */
proto.TxInputType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addAddressN(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPrevHash(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPrevIndex(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setScriptSig(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSequence(value);
      break;
    case 6:
      var value = /** @type {!proto.InputScriptType} */ (reader.readEnum());
      msg.setScriptType(value);
      break;
    case 7:
      var value = new proto.MultisigRedeemScriptType;
      reader.readMessage(value,proto.MultisigRedeemScriptType.deserializeBinaryFromReader);
      msg.setMultisig(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAmount(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDecredTree(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDecredScriptVersion(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TxInputType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TxInputType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TxInputType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxInputType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = /** @type {!proto.InputScriptType} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeEnum(
      6,
      f
    );
  }
  f = message.getMultisig();
  if (f != null) {
    writer.writeMessage(
      7,
      f,
      proto.MultisigRedeemScriptType.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeUint64(
      8,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeUint32(
      9,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeUint32(
      10,
      f
    );
  }
};


/**
 * repeated uint32 address_n = 1;
 * @return {!Array<number>}
 */
proto.TxInputType.prototype.getAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array<number>} value */
proto.TxInputType.prototype.setAddressNList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.TxInputType.prototype.addAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.TxInputType.prototype.clearAddressNList = function() {
  this.setAddressNList([]);
};


/**
 * required bytes prev_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.TxInputType.prototype.getPrevHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * required bytes prev_hash = 2;
 * This is a type-conversion wrapper around `getPrevHash()`
 * @return {string}
 */
proto.TxInputType.prototype.getPrevHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPrevHash()));
};


/**
 * required bytes prev_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPrevHash()`
 * @return {!Uint8Array}
 */
proto.TxInputType.prototype.getPrevHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPrevHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.TxInputType.prototype.setPrevHash = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.TxInputType.prototype.clearPrevHash = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxInputType.prototype.hasPrevHash = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * required uint32 prev_index = 3;
 * @return {number}
 */
proto.TxInputType.prototype.getPrevIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.TxInputType.prototype.setPrevIndex = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.TxInputType.prototype.clearPrevIndex = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxInputType.prototype.hasPrevIndex = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bytes script_sig = 4;
 * @return {!(string|Uint8Array)}
 */
proto.TxInputType.prototype.getScriptSig = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes script_sig = 4;
 * This is a type-conversion wrapper around `getScriptSig()`
 * @return {string}
 */
proto.TxInputType.prototype.getScriptSig_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getScriptSig()));
};


/**
 * optional bytes script_sig = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getScriptSig()`
 * @return {!Uint8Array}
 */
proto.TxInputType.prototype.getScriptSig_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getScriptSig()));
};


/** @param {!(string|Uint8Array)} value */
proto.TxInputType.prototype.setScriptSig = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.TxInputType.prototype.clearScriptSig = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxInputType.prototype.hasScriptSig = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional uint32 sequence = 5;
 * @return {number}
 */
proto.TxInputType.prototype.getSequence = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, -1));
};


/** @param {number} value */
proto.TxInputType.prototype.setSequence = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.TxInputType.prototype.clearSequence = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxInputType.prototype.hasSequence = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional InputScriptType script_type = 6;
 * @return {!proto.InputScriptType}
 */
proto.TxInputType.prototype.getScriptType = function() {
  return /** @type {!proto.InputScriptType} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {!proto.InputScriptType} value */
proto.TxInputType.prototype.setScriptType = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.TxInputType.prototype.clearScriptType = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxInputType.prototype.hasScriptType = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional MultisigRedeemScriptType multisig = 7;
 * @return {?proto.MultisigRedeemScriptType}
 */
proto.TxInputType.prototype.getMultisig = function() {
  return /** @type{?proto.MultisigRedeemScriptType} */ (
    jspb.Message.getWrapperField(this, proto.MultisigRedeemScriptType, 7));
};


/** @param {?proto.MultisigRedeemScriptType|undefined} value */
proto.TxInputType.prototype.setMultisig = function(value) {
  jspb.Message.setWrapperField(this, 7, value);
};


proto.TxInputType.prototype.clearMultisig = function() {
  this.setMultisig(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxInputType.prototype.hasMultisig = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional uint64 amount = 8;
 * @return {number}
 */
proto.TxInputType.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.TxInputType.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.TxInputType.prototype.clearAmount = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxInputType.prototype.hasAmount = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional uint32 decred_tree = 9;
 * @return {number}
 */
proto.TxInputType.prototype.getDecredTree = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.TxInputType.prototype.setDecredTree = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.TxInputType.prototype.clearDecredTree = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxInputType.prototype.hasDecredTree = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional uint32 decred_script_version = 10;
 * @return {number}
 */
proto.TxInputType.prototype.getDecredScriptVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.TxInputType.prototype.setDecredScriptVersion = function(value) {
  jspb.Message.setField(this, 10, value);
};


proto.TxInputType.prototype.clearDecredScriptVersion = function() {
  jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxInputType.prototype.hasDecredScriptVersion = function() {
  return jspb.Message.getField(this, 10) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TxOutputType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.TxOutputType.repeatedFields_, null);
};
goog.inherits(proto.TxOutputType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.TxOutputType.displayName = 'proto.TxOutputType';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.TxOutputType.repeatedFields_ = [2];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TxOutputType.prototype.toObject = function(opt_includeInstance) {
  return proto.TxOutputType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TxOutputType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxOutputType.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getField(msg, 1),
    addressNList: jspb.Message.getRepeatedField(msg, 2),
    amount: jspb.Message.getField(msg, 3),
    scriptType: jspb.Message.getField(msg, 4),
    multisig: (f = msg.getMultisig()) && proto.MultisigRedeemScriptType.toObject(includeInstance, f),
    opReturnData: msg.getOpReturnData_asB64(),
    addressType: jspb.Message.getField(msg, 7),
    exchangeType: (f = msg.getExchangeType()) && proto.ExchangeType.toObject(includeInstance, f),
    decredScriptVersion: jspb.Message.getField(msg, 9)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TxOutputType}
 */
proto.TxOutputType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TxOutputType;
  return proto.TxOutputType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TxOutputType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TxOutputType}
 */
proto.TxOutputType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addAddressN(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAmount(value);
      break;
    case 4:
      var value = /** @type {!proto.OutputScriptType} */ (reader.readEnum());
      msg.setScriptType(value);
      break;
    case 5:
      var value = new proto.MultisigRedeemScriptType;
      reader.readMessage(value,proto.MultisigRedeemScriptType.deserializeBinaryFromReader);
      msg.setMultisig(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setOpReturnData(value);
      break;
    case 7:
      var value = /** @type {!proto.OutputAddressType} */ (reader.readEnum());
      msg.setAddressType(value);
      break;
    case 8:
      var value = new proto.ExchangeType;
      reader.readMessage(value,proto.ExchangeType.deserializeBinaryFromReader);
      msg.setExchangeType(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDecredScriptVersion(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TxOutputType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TxOutputType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TxOutputType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxOutputType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint64(
      3,
      f
    );
  }
  f = /** @type {!proto.OutputScriptType} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeEnum(
      4,
      f
    );
  }
  f = message.getMultisig();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      proto.MultisigRedeemScriptType.serializeBinaryToWriter
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeBytes(
      6,
      f
    );
  }
  f = /** @type {!proto.OutputAddressType} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeEnum(
      7,
      f
    );
  }
  f = message.getExchangeType();
  if (f != null) {
    writer.writeMessage(
      8,
      f,
      proto.ExchangeType.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeUint32(
      9,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.TxOutputType.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.TxOutputType.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.TxOutputType.prototype.clearAddress = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxOutputType.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated uint32 address_n = 2;
 * @return {!Array<number>}
 */
proto.TxOutputType.prototype.getAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 2));
};


/** @param {!Array<number>} value */
proto.TxOutputType.prototype.setAddressNList = function(value) {
  jspb.Message.setField(this, 2, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.TxOutputType.prototype.addAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 2, value, opt_index);
};


proto.TxOutputType.prototype.clearAddressNList = function() {
  this.setAddressNList([]);
};


/**
 * required uint64 amount = 3;
 * @return {number}
 */
proto.TxOutputType.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.TxOutputType.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.TxOutputType.prototype.clearAmount = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxOutputType.prototype.hasAmount = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * required OutputScriptType script_type = 4;
 * @return {!proto.OutputScriptType}
 */
proto.TxOutputType.prototype.getScriptType = function() {
  return /** @type {!proto.OutputScriptType} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {!proto.OutputScriptType} value */
proto.TxOutputType.prototype.setScriptType = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.TxOutputType.prototype.clearScriptType = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxOutputType.prototype.hasScriptType = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional MultisigRedeemScriptType multisig = 5;
 * @return {?proto.MultisigRedeemScriptType}
 */
proto.TxOutputType.prototype.getMultisig = function() {
  return /** @type{?proto.MultisigRedeemScriptType} */ (
    jspb.Message.getWrapperField(this, proto.MultisigRedeemScriptType, 5));
};


/** @param {?proto.MultisigRedeemScriptType|undefined} value */
proto.TxOutputType.prototype.setMultisig = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.TxOutputType.prototype.clearMultisig = function() {
  this.setMultisig(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxOutputType.prototype.hasMultisig = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional bytes op_return_data = 6;
 * @return {!(string|Uint8Array)}
 */
proto.TxOutputType.prototype.getOpReturnData = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * optional bytes op_return_data = 6;
 * This is a type-conversion wrapper around `getOpReturnData()`
 * @return {string}
 */
proto.TxOutputType.prototype.getOpReturnData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getOpReturnData()));
};


/**
 * optional bytes op_return_data = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getOpReturnData()`
 * @return {!Uint8Array}
 */
proto.TxOutputType.prototype.getOpReturnData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getOpReturnData()));
};


/** @param {!(string|Uint8Array)} value */
proto.TxOutputType.prototype.setOpReturnData = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.TxOutputType.prototype.clearOpReturnData = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxOutputType.prototype.hasOpReturnData = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional OutputAddressType address_type = 7;
 * @return {!proto.OutputAddressType}
 */
proto.TxOutputType.prototype.getAddressType = function() {
  return /** @type {!proto.OutputAddressType} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {!proto.OutputAddressType} value */
proto.TxOutputType.prototype.setAddressType = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.TxOutputType.prototype.clearAddressType = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxOutputType.prototype.hasAddressType = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional ExchangeType exchange_type = 8;
 * @return {?proto.ExchangeType}
 */
proto.TxOutputType.prototype.getExchangeType = function() {
  return /** @type{?proto.ExchangeType} */ (
    jspb.Message.getWrapperField(this, proto.ExchangeType, 8));
};


/** @param {?proto.ExchangeType|undefined} value */
proto.TxOutputType.prototype.setExchangeType = function(value) {
  jspb.Message.setWrapperField(this, 8, value);
};


proto.TxOutputType.prototype.clearExchangeType = function() {
  this.setExchangeType(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxOutputType.prototype.hasExchangeType = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional uint32 decred_script_version = 9;
 * @return {number}
 */
proto.TxOutputType.prototype.getDecredScriptVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.TxOutputType.prototype.setDecredScriptVersion = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.TxOutputType.prototype.clearDecredScriptVersion = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxOutputType.prototype.hasDecredScriptVersion = function() {
  return jspb.Message.getField(this, 9) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TxOutputBinType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.TxOutputBinType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.TxOutputBinType.displayName = 'proto.TxOutputBinType';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TxOutputBinType.prototype.toObject = function(opt_includeInstance) {
  return proto.TxOutputBinType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TxOutputBinType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxOutputBinType.toObject = function(includeInstance, msg) {
  var f, obj = {
    amount: jspb.Message.getField(msg, 1),
    scriptPubkey: msg.getScriptPubkey_asB64(),
    decredScriptVersion: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TxOutputBinType}
 */
proto.TxOutputBinType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TxOutputBinType;
  return proto.TxOutputBinType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TxOutputBinType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TxOutputBinType}
 */
proto.TxOutputBinType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint64());
      msg.setAmount(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setScriptPubkey(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDecredScriptVersion(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TxOutputBinType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TxOutputBinType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TxOutputBinType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxOutputBinType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint64(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * required uint64 amount = 1;
 * @return {number}
 */
proto.TxOutputBinType.prototype.getAmount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.TxOutputBinType.prototype.setAmount = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.TxOutputBinType.prototype.clearAmount = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxOutputBinType.prototype.hasAmount = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required bytes script_pubkey = 2;
 * @return {!(string|Uint8Array)}
 */
proto.TxOutputBinType.prototype.getScriptPubkey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * required bytes script_pubkey = 2;
 * This is a type-conversion wrapper around `getScriptPubkey()`
 * @return {string}
 */
proto.TxOutputBinType.prototype.getScriptPubkey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getScriptPubkey()));
};


/**
 * required bytes script_pubkey = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getScriptPubkey()`
 * @return {!Uint8Array}
 */
proto.TxOutputBinType.prototype.getScriptPubkey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getScriptPubkey()));
};


/** @param {!(string|Uint8Array)} value */
proto.TxOutputBinType.prototype.setScriptPubkey = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.TxOutputBinType.prototype.clearScriptPubkey = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxOutputBinType.prototype.hasScriptPubkey = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint32 decred_script_version = 3;
 * @return {number}
 */
proto.TxOutputBinType.prototype.getDecredScriptVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.TxOutputBinType.prototype.setDecredScriptVersion = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.TxOutputBinType.prototype.clearDecredScriptVersion = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxOutputBinType.prototype.hasDecredScriptVersion = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TransactionType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.TransactionType.repeatedFields_, null);
};
goog.inherits(proto.TransactionType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.TransactionType.displayName = 'proto.TransactionType';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.TransactionType.repeatedFields_ = [2,3,5];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TransactionType.prototype.toObject = function(opt_includeInstance) {
  return proto.TransactionType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TransactionType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TransactionType.toObject = function(includeInstance, msg) {
  var f, obj = {
    version: jspb.Message.getField(msg, 1),
    inputsList: jspb.Message.toObjectList(msg.getInputsList(),
    proto.TxInputType.toObject, includeInstance),
    binOutputsList: jspb.Message.toObjectList(msg.getBinOutputsList(),
    proto.TxOutputBinType.toObject, includeInstance),
    outputsList: jspb.Message.toObjectList(msg.getOutputsList(),
    proto.TxOutputType.toObject, includeInstance),
    lockTime: jspb.Message.getField(msg, 4),
    inputsCnt: jspb.Message.getField(msg, 6),
    outputsCnt: jspb.Message.getField(msg, 7),
    extraData: msg.getExtraData_asB64(),
    extraDataLen: jspb.Message.getField(msg, 9),
    expiry: jspb.Message.getField(msg, 10),
    overwintered: jspb.Message.getField(msg, 11)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TransactionType}
 */
proto.TransactionType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TransactionType;
  return proto.TransactionType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TransactionType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TransactionType}
 */
proto.TransactionType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVersion(value);
      break;
    case 2:
      var value = new proto.TxInputType;
      reader.readMessage(value,proto.TxInputType.deserializeBinaryFromReader);
      msg.addInputs(value);
      break;
    case 3:
      var value = new proto.TxOutputBinType;
      reader.readMessage(value,proto.TxOutputBinType.deserializeBinaryFromReader);
      msg.addBinOutputs(value);
      break;
    case 5:
      var value = new proto.TxOutputType;
      reader.readMessage(value,proto.TxOutputType.deserializeBinaryFromReader);
      msg.addOutputs(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLockTime(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setInputsCnt(value);
      break;
    case 7:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputsCnt(value);
      break;
    case 8:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setExtraData(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExtraDataLen(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExpiry(value);
      break;
    case 11:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setOverwintered(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TransactionType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TransactionType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TransactionType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TransactionType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = message.getInputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      2,
      f,
      proto.TxInputType.serializeBinaryToWriter
    );
  }
  f = message.getBinOutputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      3,
      f,
      proto.TxOutputBinType.serializeBinaryToWriter
    );
  }
  f = message.getOutputsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      5,
      f,
      proto.TxOutputType.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeUint32(
      7,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeBytes(
      8,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeUint32(
      9,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeUint32(
      10,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 11));
  if (f != null) {
    writer.writeBool(
      11,
      f
    );
  }
};


/**
 * optional uint32 version = 1;
 * @return {number}
 */
proto.TransactionType.prototype.getVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.TransactionType.prototype.setVersion = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.TransactionType.prototype.clearVersion = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TransactionType.prototype.hasVersion = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * repeated TxInputType inputs = 2;
 * @return {!Array<!proto.TxInputType>}
 */
proto.TransactionType.prototype.getInputsList = function() {
  return /** @type{!Array<!proto.TxInputType>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.TxInputType, 2));
};


/** @param {!Array<!proto.TxInputType>} value */
proto.TransactionType.prototype.setInputsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 2, value);
};


/**
 * @param {!proto.TxInputType=} opt_value
 * @param {number=} opt_index
 * @return {!proto.TxInputType}
 */
proto.TransactionType.prototype.addInputs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 2, opt_value, proto.TxInputType, opt_index);
};


proto.TransactionType.prototype.clearInputsList = function() {
  this.setInputsList([]);
};


/**
 * repeated TxOutputBinType bin_outputs = 3;
 * @return {!Array<!proto.TxOutputBinType>}
 */
proto.TransactionType.prototype.getBinOutputsList = function() {
  return /** @type{!Array<!proto.TxOutputBinType>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.TxOutputBinType, 3));
};


/** @param {!Array<!proto.TxOutputBinType>} value */
proto.TransactionType.prototype.setBinOutputsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 3, value);
};


/**
 * @param {!proto.TxOutputBinType=} opt_value
 * @param {number=} opt_index
 * @return {!proto.TxOutputBinType}
 */
proto.TransactionType.prototype.addBinOutputs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 3, opt_value, proto.TxOutputBinType, opt_index);
};


proto.TransactionType.prototype.clearBinOutputsList = function() {
  this.setBinOutputsList([]);
};


/**
 * repeated TxOutputType outputs = 5;
 * @return {!Array<!proto.TxOutputType>}
 */
proto.TransactionType.prototype.getOutputsList = function() {
  return /** @type{!Array<!proto.TxOutputType>} */ (
    jspb.Message.getRepeatedWrapperField(this, proto.TxOutputType, 5));
};


/** @param {!Array<!proto.TxOutputType>} value */
proto.TransactionType.prototype.setOutputsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 5, value);
};


/**
 * @param {!proto.TxOutputType=} opt_value
 * @param {number=} opt_index
 * @return {!proto.TxOutputType}
 */
proto.TransactionType.prototype.addOutputs = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 5, opt_value, proto.TxOutputType, opt_index);
};


proto.TransactionType.prototype.clearOutputsList = function() {
  this.setOutputsList([]);
};


/**
 * optional uint32 lock_time = 4;
 * @return {number}
 */
proto.TransactionType.prototype.getLockTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.TransactionType.prototype.setLockTime = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.TransactionType.prototype.clearLockTime = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TransactionType.prototype.hasLockTime = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional uint32 inputs_cnt = 6;
 * @return {number}
 */
proto.TransactionType.prototype.getInputsCnt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.TransactionType.prototype.setInputsCnt = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.TransactionType.prototype.clearInputsCnt = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TransactionType.prototype.hasInputsCnt = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional uint32 outputs_cnt = 7;
 * @return {number}
 */
proto.TransactionType.prototype.getOutputsCnt = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 7, 0));
};


/** @param {number} value */
proto.TransactionType.prototype.setOutputsCnt = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.TransactionType.prototype.clearOutputsCnt = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TransactionType.prototype.hasOutputsCnt = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional bytes extra_data = 8;
 * @return {!(string|Uint8Array)}
 */
proto.TransactionType.prototype.getExtraData = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/**
 * optional bytes extra_data = 8;
 * This is a type-conversion wrapper around `getExtraData()`
 * @return {string}
 */
proto.TransactionType.prototype.getExtraData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getExtraData()));
};


/**
 * optional bytes extra_data = 8;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getExtraData()`
 * @return {!Uint8Array}
 */
proto.TransactionType.prototype.getExtraData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getExtraData()));
};


/** @param {!(string|Uint8Array)} value */
proto.TransactionType.prototype.setExtraData = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.TransactionType.prototype.clearExtraData = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TransactionType.prototype.hasExtraData = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional uint32 extra_data_len = 9;
 * @return {number}
 */
proto.TransactionType.prototype.getExtraDataLen = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.TransactionType.prototype.setExtraDataLen = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.TransactionType.prototype.clearExtraDataLen = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TransactionType.prototype.hasExtraDataLen = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional uint32 expiry = 10;
 * @return {number}
 */
proto.TransactionType.prototype.getExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.TransactionType.prototype.setExpiry = function(value) {
  jspb.Message.setField(this, 10, value);
};


proto.TransactionType.prototype.clearExpiry = function() {
  jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TransactionType.prototype.hasExpiry = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional bool overwintered = 11;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.TransactionType.prototype.getOverwintered = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 11, false));
};


/** @param {boolean} value */
proto.TransactionType.prototype.setOverwintered = function(value) {
  jspb.Message.setField(this, 11, value);
};


proto.TransactionType.prototype.clearOverwintered = function() {
  jspb.Message.setField(this, 11, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TransactionType.prototype.hasOverwintered = function() {
  return jspb.Message.getField(this, 11) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.RawTransactionType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.RawTransactionType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.RawTransactionType.displayName = 'proto.RawTransactionType';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.RawTransactionType.prototype.toObject = function(opt_includeInstance) {
  return proto.RawTransactionType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.RawTransactionType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RawTransactionType.toObject = function(includeInstance, msg) {
  var f, obj = {
    payload: msg.getPayload_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.RawTransactionType}
 */
proto.RawTransactionType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.RawTransactionType;
  return proto.RawTransactionType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.RawTransactionType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.RawTransactionType}
 */
proto.RawTransactionType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPayload(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.RawTransactionType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.RawTransactionType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.RawTransactionType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RawTransactionType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * required bytes payload = 1;
 * @return {!(string|Uint8Array)}
 */
proto.RawTransactionType.prototype.getPayload = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * required bytes payload = 1;
 * This is a type-conversion wrapper around `getPayload()`
 * @return {string}
 */
proto.RawTransactionType.prototype.getPayload_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPayload()));
};


/**
 * required bytes payload = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPayload()`
 * @return {!Uint8Array}
 */
proto.RawTransactionType.prototype.getPayload_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPayload()));
};


/** @param {!(string|Uint8Array)} value */
proto.RawTransactionType.prototype.setPayload = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.RawTransactionType.prototype.clearPayload = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.RawTransactionType.prototype.hasPayload = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TxRequestDetailsType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.TxRequestDetailsType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.TxRequestDetailsType.displayName = 'proto.TxRequestDetailsType';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TxRequestDetailsType.prototype.toObject = function(opt_includeInstance) {
  return proto.TxRequestDetailsType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TxRequestDetailsType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxRequestDetailsType.toObject = function(includeInstance, msg) {
  var f, obj = {
    requestIndex: jspb.Message.getField(msg, 1),
    txHash: msg.getTxHash_asB64(),
    extraDataLen: jspb.Message.getField(msg, 3),
    extraDataOffset: jspb.Message.getField(msg, 4)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TxRequestDetailsType}
 */
proto.TxRequestDetailsType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TxRequestDetailsType;
  return proto.TxRequestDetailsType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TxRequestDetailsType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TxRequestDetailsType}
 */
proto.TxRequestDetailsType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setRequestIndex(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTxHash(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExtraDataLen(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExtraDataOffset(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TxRequestDetailsType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TxRequestDetailsType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TxRequestDetailsType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxRequestDetailsType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeUint32(
      4,
      f
    );
  }
};


/**
 * optional uint32 request_index = 1;
 * @return {number}
 */
proto.TxRequestDetailsType.prototype.getRequestIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.TxRequestDetailsType.prototype.setRequestIndex = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.TxRequestDetailsType.prototype.clearRequestIndex = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxRequestDetailsType.prototype.hasRequestIndex = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes tx_hash = 2;
 * @return {!(string|Uint8Array)}
 */
proto.TxRequestDetailsType.prototype.getTxHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes tx_hash = 2;
 * This is a type-conversion wrapper around `getTxHash()`
 * @return {string}
 */
proto.TxRequestDetailsType.prototype.getTxHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTxHash()));
};


/**
 * optional bytes tx_hash = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTxHash()`
 * @return {!Uint8Array}
 */
proto.TxRequestDetailsType.prototype.getTxHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTxHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.TxRequestDetailsType.prototype.setTxHash = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.TxRequestDetailsType.prototype.clearTxHash = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxRequestDetailsType.prototype.hasTxHash = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint32 extra_data_len = 3;
 * @return {number}
 */
proto.TxRequestDetailsType.prototype.getExtraDataLen = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.TxRequestDetailsType.prototype.setExtraDataLen = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.TxRequestDetailsType.prototype.clearExtraDataLen = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxRequestDetailsType.prototype.hasExtraDataLen = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional uint32 extra_data_offset = 4;
 * @return {number}
 */
proto.TxRequestDetailsType.prototype.getExtraDataOffset = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.TxRequestDetailsType.prototype.setExtraDataOffset = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.TxRequestDetailsType.prototype.clearExtraDataOffset = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxRequestDetailsType.prototype.hasExtraDataOffset = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TxRequestSerializedType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.TxRequestSerializedType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.TxRequestSerializedType.displayName = 'proto.TxRequestSerializedType';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TxRequestSerializedType.prototype.toObject = function(opt_includeInstance) {
  return proto.TxRequestSerializedType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TxRequestSerializedType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxRequestSerializedType.toObject = function(includeInstance, msg) {
  var f, obj = {
    signatureIndex: jspb.Message.getField(msg, 1),
    signature: msg.getSignature_asB64(),
    serializedTx: msg.getSerializedTx_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TxRequestSerializedType}
 */
proto.TxRequestSerializedType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TxRequestSerializedType;
  return proto.TxRequestSerializedType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TxRequestSerializedType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TxRequestSerializedType}
 */
proto.TxRequestSerializedType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSignatureIndex(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSerializedTx(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TxRequestSerializedType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TxRequestSerializedType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TxRequestSerializedType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxRequestSerializedType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional uint32 signature_index = 1;
 * @return {number}
 */
proto.TxRequestSerializedType.prototype.getSignatureIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.TxRequestSerializedType.prototype.setSignatureIndex = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.TxRequestSerializedType.prototype.clearSignatureIndex = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxRequestSerializedType.prototype.hasSignatureIndex = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes signature = 2;
 * @return {!(string|Uint8Array)}
 */
proto.TxRequestSerializedType.prototype.getSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes signature = 2;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.TxRequestSerializedType.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.TxRequestSerializedType.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value */
proto.TxRequestSerializedType.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.TxRequestSerializedType.prototype.clearSignature = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxRequestSerializedType.prototype.hasSignature = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes serialized_tx = 3;
 * @return {!(string|Uint8Array)}
 */
proto.TxRequestSerializedType.prototype.getSerializedTx = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes serialized_tx = 3;
 * This is a type-conversion wrapper around `getSerializedTx()`
 * @return {string}
 */
proto.TxRequestSerializedType.prototype.getSerializedTx_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSerializedTx()));
};


/**
 * optional bytes serialized_tx = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSerializedTx()`
 * @return {!Uint8Array}
 */
proto.TxRequestSerializedType.prototype.getSerializedTx_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSerializedTx()));
};


/** @param {!(string|Uint8Array)} value */
proto.TxRequestSerializedType.prototype.setSerializedTx = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.TxRequestSerializedType.prototype.clearSerializedTx = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxRequestSerializedType.prototype.hasSerializedTx = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.IdentityType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.IdentityType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.IdentityType.displayName = 'proto.IdentityType';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.IdentityType.prototype.toObject = function(opt_includeInstance) {
  return proto.IdentityType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.IdentityType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.IdentityType.toObject = function(includeInstance, msg) {
  var f, obj = {
    proto: jspb.Message.getField(msg, 1),
    user: jspb.Message.getField(msg, 2),
    host: jspb.Message.getField(msg, 3),
    port: jspb.Message.getField(msg, 4),
    path: jspb.Message.getField(msg, 5),
    index: jspb.Message.getFieldWithDefault(msg, 6, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.IdentityType}
 */
proto.IdentityType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.IdentityType;
  return proto.IdentityType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.IdentityType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.IdentityType}
 */
proto.IdentityType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setProto(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setUser(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setHost(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setPort(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setPath(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setIndex(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.IdentityType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.IdentityType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.IdentityType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.IdentityType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeString(
      4,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeString(
      5,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeUint32(
      6,
      f
    );
  }
};


/**
 * optional string proto = 1;
 * @return {string}
 */
proto.IdentityType.prototype.getProto = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.IdentityType.prototype.setProto = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.IdentityType.prototype.clearProto = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.IdentityType.prototype.hasProto = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string user = 2;
 * @return {string}
 */
proto.IdentityType.prototype.getUser = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.IdentityType.prototype.setUser = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.IdentityType.prototype.clearUser = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.IdentityType.prototype.hasUser = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional string host = 3;
 * @return {string}
 */
proto.IdentityType.prototype.getHost = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.IdentityType.prototype.setHost = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.IdentityType.prototype.clearHost = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.IdentityType.prototype.hasHost = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional string port = 4;
 * @return {string}
 */
proto.IdentityType.prototype.getPort = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.IdentityType.prototype.setPort = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.IdentityType.prototype.clearPort = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.IdentityType.prototype.hasPort = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional string path = 5;
 * @return {string}
 */
proto.IdentityType.prototype.getPath = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.IdentityType.prototype.setPath = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.IdentityType.prototype.clearPath = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.IdentityType.prototype.hasPath = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional uint32 index = 6;
 * @return {number}
 */
proto.IdentityType.prototype.getIndex = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.IdentityType.prototype.setIndex = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.IdentityType.prototype.clearIndex = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.IdentityType.prototype.hasIndex = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.PolicyType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.PolicyType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.PolicyType.displayName = 'proto.PolicyType';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.PolicyType.prototype.toObject = function(opt_includeInstance) {
  return proto.PolicyType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.PolicyType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.PolicyType.toObject = function(includeInstance, msg) {
  var f, obj = {
    policyName: jspb.Message.getField(msg, 1),
    enabled: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.PolicyType}
 */
proto.PolicyType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.PolicyType;
  return proto.PolicyType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.PolicyType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.PolicyType}
 */
proto.PolicyType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setPolicyName(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setEnabled(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.PolicyType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.PolicyType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.PolicyType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.PolicyType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBool(
      2,
      f
    );
  }
};


/**
 * optional string policy_name = 1;
 * @return {string}
 */
proto.PolicyType.prototype.getPolicyName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.PolicyType.prototype.setPolicyName = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.PolicyType.prototype.clearPolicyName = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.PolicyType.prototype.hasPolicyName = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool enabled = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.PolicyType.prototype.getEnabled = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.PolicyType.prototype.setEnabled = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.PolicyType.prototype.clearEnabled = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.PolicyType.prototype.hasEnabled = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ExchangeType = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ExchangeType.repeatedFields_, null);
};
goog.inherits(proto.ExchangeType, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ExchangeType.displayName = 'proto.ExchangeType';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ExchangeType.repeatedFields_ = [3,4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ExchangeType.prototype.toObject = function(opt_includeInstance) {
  return proto.ExchangeType.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ExchangeType} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ExchangeType.toObject = function(includeInstance, msg) {
  var f, obj = {
    signedExchangeResponse: (f = msg.getSignedExchangeResponse()) && exchange_pb.SignedExchangeResponse.toObject(includeInstance, f),
    withdrawalCoinName: jspb.Message.getFieldWithDefault(msg, 2, "Bitcoin"),
    withdrawalAddressNList: jspb.Message.getRepeatedField(msg, 3),
    returnAddressNList: jspb.Message.getRepeatedField(msg, 4)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ExchangeType}
 */
proto.ExchangeType.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ExchangeType;
  return proto.ExchangeType.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ExchangeType} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ExchangeType}
 */
proto.ExchangeType.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new exchange_pb.SignedExchangeResponse;
      reader.readMessage(value,exchange_pb.SignedExchangeResponse.deserializeBinaryFromReader);
      msg.setSignedExchangeResponse(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setWithdrawalCoinName(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addWithdrawalAddressN(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addReturnAddressN(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ExchangeType.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ExchangeType.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ExchangeType} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ExchangeType.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getSignedExchangeResponse();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      exchange_pb.SignedExchangeResponse.serializeBinaryToWriter
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = message.getWithdrawalAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      3,
      f
    );
  }
  f = message.getReturnAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      4,
      f
    );
  }
};


/**
 * optional SignedExchangeResponse signed_exchange_response = 1;
 * @return {?proto.SignedExchangeResponse}
 */
proto.ExchangeType.prototype.getSignedExchangeResponse = function() {
  return /** @type{?proto.SignedExchangeResponse} */ (
    jspb.Message.getWrapperField(this, exchange_pb.SignedExchangeResponse, 1));
};


/** @param {?proto.SignedExchangeResponse|undefined} value */
proto.ExchangeType.prototype.setSignedExchangeResponse = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.ExchangeType.prototype.clearSignedExchangeResponse = function() {
  this.setSignedExchangeResponse(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ExchangeType.prototype.hasSignedExchangeResponse = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string withdrawal_coin_name = 2;
 * @return {string}
 */
proto.ExchangeType.prototype.getWithdrawalCoinName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, "Bitcoin"));
};


/** @param {string} value */
proto.ExchangeType.prototype.setWithdrawalCoinName = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.ExchangeType.prototype.clearWithdrawalCoinName = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ExchangeType.prototype.hasWithdrawalCoinName = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * repeated uint32 withdrawal_address_n = 3;
 * @return {!Array<number>}
 */
proto.ExchangeType.prototype.getWithdrawalAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 3));
};


/** @param {!Array<number>} value */
proto.ExchangeType.prototype.setWithdrawalAddressNList = function(value) {
  jspb.Message.setField(this, 3, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.ExchangeType.prototype.addWithdrawalAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 3, value, opt_index);
};


proto.ExchangeType.prototype.clearWithdrawalAddressNList = function() {
  this.setWithdrawalAddressNList([]);
};


/**
 * repeated uint32 return_address_n = 4;
 * @return {!Array<number>}
 */
proto.ExchangeType.prototype.getReturnAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 4));
};


/** @param {!Array<number>} value */
proto.ExchangeType.prototype.setReturnAddressNList = function(value) {
  jspb.Message.setField(this, 4, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.ExchangeType.prototype.addReturnAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 4, value, opt_index);
};


proto.ExchangeType.prototype.clearReturnAddressNList = function() {
  this.setReturnAddressNList([]);
};


/**
 * @enum {number}
 */
proto.FailureType = {
  FAILURE_UNEXPECTEDMESSAGE: 1,
  FAILURE_BUTTONEXPECTED: 2,
  FAILURE_SYNTAXERROR: 3,
  FAILURE_ACTIONCANCELLED: 4,
  FAILURE_PINEXPECTED: 5,
  FAILURE_PINCANCELLED: 6,
  FAILURE_PININVALID: 7,
  FAILURE_INVALIDSIGNATURE: 8,
  FAILURE_OTHER: 9,
  FAILURE_NOTENOUGHFUNDS: 10,
  FAILURE_NOTINITIALIZED: 11,
  FAILURE_PINMISMATCH: 12,
  FAILURE_FIRMWAREERROR: 99
};

/**
 * @enum {number}
 */
proto.OutputScriptType = {
  PAYTOADDRESS: 0,
  PAYTOSCRIPTHASH: 1,
  PAYTOMULTISIG: 2,
  PAYTOOPRETURN: 3,
  PAYTOWITNESS: 4,
  PAYTOP2SHWITNESS: 5
};

/**
 * @enum {number}
 */
proto.InputScriptType = {
  SPENDADDRESS: 0,
  SPENDMULTISIG: 1,
  EXTERNAL: 2,
  SPENDWITNESS: 3,
  SPENDP2SHWITNESS: 4
};

/**
 * @enum {number}
 */
proto.RequestType = {
  TXINPUT: 0,
  TXOUTPUT: 1,
  TXMETA: 2,
  TXFINISHED: 3,
  TXEXTRADATA: 4
};

/**
 * @enum {number}
 */
proto.OutputAddressType = {
  SPEND: 0,
  TRANSFER: 1,
  CHANGE: 2,
  EXCHANGE: 3
};

/**
 * @enum {number}
 */
proto.ButtonRequestType = {
  BUTTONREQUEST_OTHER: 1,
  BUTTONREQUEST_FEEOVERTHRESHOLD: 2,
  BUTTONREQUEST_CONFIRMOUTPUT: 3,
  BUTTONREQUEST_RESETDEVICE: 4,
  BUTTONREQUEST_CONFIRMWORD: 5,
  BUTTONREQUEST_WIPEDEVICE: 6,
  BUTTONREQUEST_PROTECTCALL: 7,
  BUTTONREQUEST_SIGNTX: 8,
  BUTTONREQUEST_FIRMWARECHECK: 9,
  BUTTONREQUEST_ADDRESS: 10,
  BUTTONREQUEST_FIRMWAREERASE: 11,
  BUTTONREQUEST_CONFIRMTRANSFERTOACCOUNT: 12,
  BUTTONREQUEST_CONFIRMTRANSFERTONODEPATH: 13,
  BUTTONREQUEST_CHANGELABEL: 14,
  BUTTONREQUEST_CHANGELANGUAGE: 15,
  BUTTONREQUEST_ENABLEPASSPHRASE: 16,
  BUTTONREQUEST_DISABLEPASSPHRASE: 17,
  BUTTONREQUEST_ENCRYPTANDSIGNMESSAGE: 18,
  BUTTONREQUEST_ENCRYPTMESSAGE: 19,
  BUTTONREQUEST_IMPORTPRIVATEKEY: 20,
  BUTTONREQUEST_IMPORTRECOVERYSENTENCE: 21,
  BUTTONREQUEST_SIGNIDENTITY: 22,
  BUTTONREQUEST_PING: 23,
  BUTTONREQUEST_REMOVEPIN: 24,
  BUTTONREQUEST_CHANGEPIN: 25,
  BUTTONREQUEST_CREATEPIN: 26,
  BUTTONREQUEST_GETENTROPY: 27,
  BUTTONREQUEST_SIGNMESSAGE: 28,
  BUTTONREQUEST_APPLYPOLICIES: 29,
  BUTTONREQUEST_SIGNEXCHANGE: 30,
  BUTTONREQUEST_AUTOLOCKDELAYMS: 31,
  BUTTONREQUEST_U2FCOUNTER: 32
};

/**
 * @enum {number}
 */
proto.PinMatrixRequestType = {
  PINMATRIXREQUESTTYPE_CURRENT: 1,
  PINMATRIXREQUESTTYPE_NEWFIRST: 2,
  PINMATRIXREQUESTTYPE_NEWSECOND: 3
};


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `wireIn`.
 * @type {!jspb.ExtensionFieldInfo<boolean>}
 */
proto.wireIn = new jspb.ExtensionFieldInfo(
    50002,
    {wireIn: 0},
    null,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         null),
    0);

google_protobuf_descriptor_pb.EnumValueOptions.extensionsBinary[50002] = new jspb.ExtensionFieldBinaryInfo(
    proto.wireIn,
    jspb.BinaryReader.prototype.readBool,
    jspb.BinaryWriter.prototype.writeBool,
    undefined,
    undefined,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
google_protobuf_descriptor_pb.EnumValueOptions.extensions[50002] = proto.wireIn;


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `wireOut`.
 * @type {!jspb.ExtensionFieldInfo<boolean>}
 */
proto.wireOut = new jspb.ExtensionFieldInfo(
    50003,
    {wireOut: 0},
    null,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         null),
    0);

google_protobuf_descriptor_pb.EnumValueOptions.extensionsBinary[50003] = new jspb.ExtensionFieldBinaryInfo(
    proto.wireOut,
    jspb.BinaryReader.prototype.readBool,
    jspb.BinaryWriter.prototype.writeBool,
    undefined,
    undefined,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
google_protobuf_descriptor_pb.EnumValueOptions.extensions[50003] = proto.wireOut;


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `wireDebugIn`.
 * @type {!jspb.ExtensionFieldInfo<boolean>}
 */
proto.wireDebugIn = new jspb.ExtensionFieldInfo(
    50004,
    {wireDebugIn: 0},
    null,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         null),
    0);

google_protobuf_descriptor_pb.EnumValueOptions.extensionsBinary[50004] = new jspb.ExtensionFieldBinaryInfo(
    proto.wireDebugIn,
    jspb.BinaryReader.prototype.readBool,
    jspb.BinaryWriter.prototype.writeBool,
    undefined,
    undefined,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
google_protobuf_descriptor_pb.EnumValueOptions.extensions[50004] = proto.wireDebugIn;


/**
 * A tuple of {field number, class constructor} for the extension
 * field named `wireDebugOut`.
 * @type {!jspb.ExtensionFieldInfo<boolean>}
 */
proto.wireDebugOut = new jspb.ExtensionFieldInfo(
    50005,
    {wireDebugOut: 0},
    null,
     /** @type {?function((boolean|undefined),!jspb.Message=): !Object} */ (
         null),
    0);

google_protobuf_descriptor_pb.EnumValueOptions.extensionsBinary[50005] = new jspb.ExtensionFieldBinaryInfo(
    proto.wireDebugOut,
    jspb.BinaryReader.prototype.readBool,
    jspb.BinaryWriter.prototype.writeBool,
    undefined,
    undefined,
    false);
// This registers the extension field with the extended class, so that
// toObject() will function correctly.
google_protobuf_descriptor_pb.EnumValueOptions.extensions[50005] = proto.wireDebugOut;

goog.object.extend(exports, proto);
