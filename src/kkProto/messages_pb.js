/**
 * @fileoverview
 * @enhanceable
 * @suppress {messageConventions} JS Compiler reports an error if a variable or
 *     field starts with 'MSG_' and isn't a translatable message.
 * @public
 */
// GENERATED CODE -- DO NOT EDIT!

var jspb = require('google-protobuf');
var goog = jspb;
var global = Function('return this')();

var types_pb = require('./types_pb.js');
goog.exportSymbol('proto.Address', null, global);
goog.exportSymbol('proto.ApplyPolicies', null, global);
goog.exportSymbol('proto.ApplySettings', null, global);
goog.exportSymbol('proto.ButtonAck', null, global);
goog.exportSymbol('proto.ButtonRequest', null, global);
goog.exportSymbol('proto.Cancel', null, global);
goog.exportSymbol('proto.ChangePin', null, global);
goog.exportSymbol('proto.CharacterAck', null, global);
goog.exportSymbol('proto.CharacterRequest', null, global);
goog.exportSymbol('proto.CipherKeyValue', null, global);
goog.exportSymbol('proto.CipheredKeyValue', null, global);
goog.exportSymbol('proto.ClearSession', null, global);
goog.exportSymbol('proto.CoinTable', null, global);
goog.exportSymbol('proto.DebugLinkDecision', null, global);
goog.exportSymbol('proto.DebugLinkFillConfig', null, global);
goog.exportSymbol('proto.DebugLinkFlashDump', null, global);
goog.exportSymbol('proto.DebugLinkFlashDumpResponse', null, global);
goog.exportSymbol('proto.DebugLinkGetState', null, global);
goog.exportSymbol('proto.DebugLinkLog', null, global);
goog.exportSymbol('proto.DebugLinkState', null, global);
goog.exportSymbol('proto.DebugLinkStop', null, global);
goog.exportSymbol('proto.DecryptMessage', null, global);
goog.exportSymbol('proto.DecryptedMessage', null, global);
goog.exportSymbol('proto.EncryptMessage', null, global);
goog.exportSymbol('proto.EncryptedMessage', null, global);
goog.exportSymbol('proto.Entropy', null, global);
goog.exportSymbol('proto.EntropyAck', null, global);
goog.exportSymbol('proto.EntropyRequest', null, global);
goog.exportSymbol('proto.EstimateTxSize', null, global);
goog.exportSymbol('proto.EthereumAddress', null, global);
goog.exportSymbol('proto.EthereumGetAddress', null, global);
goog.exportSymbol('proto.EthereumMessageSignature', null, global);
goog.exportSymbol('proto.EthereumSignMessage', null, global);
goog.exportSymbol('proto.EthereumSignTx', null, global);
goog.exportSymbol('proto.EthereumTxAck', null, global);
goog.exportSymbol('proto.EthereumTxRequest', null, global);
goog.exportSymbol('proto.EthereumVerifyMessage', null, global);
goog.exportSymbol('proto.Failure', null, global);
goog.exportSymbol('proto.Features', null, global);
goog.exportSymbol('proto.FirmwareErase', null, global);
goog.exportSymbol('proto.FirmwareUpload', null, global);
goog.exportSymbol('proto.FlashHash', null, global);
goog.exportSymbol('proto.FlashHashResponse', null, global);
goog.exportSymbol('proto.FlashWrite', null, global);
goog.exportSymbol('proto.GetAddress', null, global);
goog.exportSymbol('proto.GetCoinTable', null, global);
goog.exportSymbol('proto.GetEntropy', null, global);
goog.exportSymbol('proto.GetFeatures', null, global);
goog.exportSymbol('proto.GetPublicKey', null, global);
goog.exportSymbol('proto.Initialize', null, global);
goog.exportSymbol('proto.LoadDevice', null, global);
goog.exportSymbol('proto.MessageSignature', null, global);
goog.exportSymbol('proto.MessageType', null, global);
goog.exportSymbol('proto.PassphraseAck', null, global);
goog.exportSymbol('proto.PassphraseRequest', null, global);
goog.exportSymbol('proto.PinMatrixAck', null, global);
goog.exportSymbol('proto.PinMatrixRequest', null, global);
goog.exportSymbol('proto.Ping', null, global);
goog.exportSymbol('proto.PublicKey', null, global);
goog.exportSymbol('proto.RawTxAck', null, global);
goog.exportSymbol('proto.RecoveryDevice', null, global);
goog.exportSymbol('proto.ResetDevice', null, global);
goog.exportSymbol('proto.SignIdentity', null, global);
goog.exportSymbol('proto.SignMessage', null, global);
goog.exportSymbol('proto.SignTx', null, global);
goog.exportSymbol('proto.SignedIdentity', null, global);
goog.exportSymbol('proto.SoftReset', null, global);
goog.exportSymbol('proto.Success', null, global);
goog.exportSymbol('proto.TxAck', null, global);
goog.exportSymbol('proto.TxRequest', null, global);
goog.exportSymbol('proto.TxSize', null, global);
goog.exportSymbol('proto.VerifyMessage', null, global);
goog.exportSymbol('proto.WipeDevice', null, global);
goog.exportSymbol('proto.WordAck', null, global);
goog.exportSymbol('proto.WordRequest', null, global);

/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Initialize = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Initialize, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.Initialize.displayName = 'proto.Initialize';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Initialize.prototype.toObject = function(opt_includeInstance) {
  return proto.Initialize.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Initialize} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Initialize.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Initialize}
 */
proto.Initialize.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Initialize;
  return proto.Initialize.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Initialize} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Initialize}
 */
proto.Initialize.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Initialize.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Initialize.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Initialize} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Initialize.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.GetFeatures = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.GetFeatures, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.GetFeatures.displayName = 'proto.GetFeatures';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.GetFeatures.prototype.toObject = function(opt_includeInstance) {
  return proto.GetFeatures.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.GetFeatures} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.GetFeatures.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.GetFeatures}
 */
proto.GetFeatures.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.GetFeatures;
  return proto.GetFeatures.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.GetFeatures} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.GetFeatures}
 */
proto.GetFeatures.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.GetFeatures.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.GetFeatures.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.GetFeatures} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.GetFeatures.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Features = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.Features.repeatedFields_, null);
};
goog.inherits(proto.Features, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.Features.displayName = 'proto.Features';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.Features.repeatedFields_ = [11,18];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Features.prototype.toObject = function(opt_includeInstance) {
  return proto.Features.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Features} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Features.toObject = function(includeInstance, msg) {
  var f, obj = {
    vendor: jspb.Message.getField(msg, 1),
    majorVersion: jspb.Message.getField(msg, 2),
    minorVersion: jspb.Message.getField(msg, 3),
    patchVersion: jspb.Message.getField(msg, 4),
    bootloaderMode: jspb.Message.getField(msg, 5),
    deviceId: jspb.Message.getField(msg, 6),
    pinProtection: jspb.Message.getField(msg, 7),
    passphraseProtection: jspb.Message.getField(msg, 8),
    language: jspb.Message.getField(msg, 9),
    label: jspb.Message.getField(msg, 10),
    coinsList: jspb.Message.toObjectList(msg.getCoinsList(),
    types_pb.CoinType.toObject, includeInstance),
    initialized: jspb.Message.getField(msg, 12),
    revision: msg.getRevision_asB64(),
    bootloaderHash: msg.getBootloaderHash_asB64(),
    imported: jspb.Message.getField(msg, 15),
    pinCached: jspb.Message.getField(msg, 16),
    passphraseCached: jspb.Message.getField(msg, 17),
    policiesList: jspb.Message.toObjectList(msg.getPoliciesList(),
    types_pb.PolicyType.toObject, includeInstance),
    model: jspb.Message.getField(msg, 21),
    firmwareVariant: jspb.Message.getField(msg, 22),
    firmwareHash: msg.getFirmwareHash_asB64(),
    noBackup: jspb.Message.getField(msg, 24)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Features}
 */
proto.Features.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Features;
  return proto.Features.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Features} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Features}
 */
proto.Features.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setVendor(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMajorVersion(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setMinorVersion(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setPatchVersion(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setBootloaderMode(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setDeviceId(value);
      break;
    case 7:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPinProtection(value);
      break;
    case 8:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPassphraseProtection(value);
      break;
    case 9:
      var value = /** @type {string} */ (reader.readString());
      msg.setLanguage(value);
      break;
    case 10:
      var value = /** @type {string} */ (reader.readString());
      msg.setLabel(value);
      break;
    case 11:
      var value = new types_pb.CoinType;
      reader.readMessage(value,types_pb.CoinType.deserializeBinaryFromReader);
      msg.addCoins(value);
      break;
    case 12:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setInitialized(value);
      break;
    case 13:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setRevision(value);
      break;
    case 14:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setBootloaderHash(value);
      break;
    case 15:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setImported(value);
      break;
    case 16:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPinCached(value);
      break;
    case 17:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPassphraseCached(value);
      break;
    case 18:
      var value = new types_pb.PolicyType;
      reader.readMessage(value,types_pb.PolicyType.deserializeBinaryFromReader);
      msg.addPolicies(value);
      break;
    case 21:
      var value = /** @type {string} */ (reader.readString());
      msg.setModel(value);
      break;
    case 22:
      var value = /** @type {string} */ (reader.readString());
      msg.setFirmwareVariant(value);
      break;
    case 23:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setFirmwareHash(value);
      break;
    case 24:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setNoBackup(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Features.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Features.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Features} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Features.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeBool(
      5,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeString(
      6,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeBool(
      7,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeBool(
      8,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeString(
      9,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeString(
      10,
      f
    );
  }
  f = message.getCoinsList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      11,
      f,
      types_pb.CoinType.serializeBinaryToWriter
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 12));
  if (f != null) {
    writer.writeBool(
      12,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 13));
  if (f != null) {
    writer.writeBytes(
      13,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 14));
  if (f != null) {
    writer.writeBytes(
      14,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 15));
  if (f != null) {
    writer.writeBool(
      15,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 16));
  if (f != null) {
    writer.writeBool(
      16,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 17));
  if (f != null) {
    writer.writeBool(
      17,
      f
    );
  }
  f = message.getPoliciesList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      18,
      f,
      types_pb.PolicyType.serializeBinaryToWriter
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 21));
  if (f != null) {
    writer.writeString(
      21,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 22));
  if (f != null) {
    writer.writeString(
      22,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 23));
  if (f != null) {
    writer.writeBytes(
      23,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 24));
  if (f != null) {
    writer.writeBool(
      24,
      f
    );
  }
};


/**
 * optional string vendor = 1;
 * @return {string}
 */
proto.Features.prototype.getVendor = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.Features.prototype.setVendor = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.Features.prototype.clearVendor = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasVendor = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 major_version = 2;
 * @return {number}
 */
proto.Features.prototype.getMajorVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.Features.prototype.setMajorVersion = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.Features.prototype.clearMajorVersion = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasMajorVersion = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint32 minor_version = 3;
 * @return {number}
 */
proto.Features.prototype.getMinorVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.Features.prototype.setMinorVersion = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.Features.prototype.clearMinorVersion = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasMinorVersion = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional uint32 patch_version = 4;
 * @return {number}
 */
proto.Features.prototype.getPatchVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.Features.prototype.setPatchVersion = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.Features.prototype.clearPatchVersion = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasPatchVersion = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional bool bootloader_mode = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.Features.prototype.getBootloaderMode = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.Features.prototype.setBootloaderMode = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.Features.prototype.clearBootloaderMode = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasBootloaderMode = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional string device_id = 6;
 * @return {string}
 */
proto.Features.prototype.getDeviceId = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/** @param {string} value */
proto.Features.prototype.setDeviceId = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.Features.prototype.clearDeviceId = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasDeviceId = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional bool pin_protection = 7;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.Features.prototype.getPinProtection = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 7, false));
};


/** @param {boolean} value */
proto.Features.prototype.setPinProtection = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.Features.prototype.clearPinProtection = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasPinProtection = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional bool passphrase_protection = 8;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.Features.prototype.getPassphraseProtection = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 8, false));
};


/** @param {boolean} value */
proto.Features.prototype.setPassphraseProtection = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.Features.prototype.clearPassphraseProtection = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasPassphraseProtection = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional string language = 9;
 * @return {string}
 */
proto.Features.prototype.getLanguage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 9, ""));
};


/** @param {string} value */
proto.Features.prototype.setLanguage = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.Features.prototype.clearLanguage = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasLanguage = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional string label = 10;
 * @return {string}
 */
proto.Features.prototype.getLabel = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 10, ""));
};


/** @param {string} value */
proto.Features.prototype.setLabel = function(value) {
  jspb.Message.setField(this, 10, value);
};


proto.Features.prototype.clearLabel = function() {
  jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasLabel = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * repeated CoinType coins = 11;
 * @return {!Array<!proto.CoinType>}
 */
proto.Features.prototype.getCoinsList = function() {
  return /** @type{!Array<!proto.CoinType>} */ (
    jspb.Message.getRepeatedWrapperField(this, types_pb.CoinType, 11));
};


/** @param {!Array<!proto.CoinType>} value */
proto.Features.prototype.setCoinsList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 11, value);
};


/**
 * @param {!proto.CoinType=} opt_value
 * @param {number=} opt_index
 * @return {!proto.CoinType}
 */
proto.Features.prototype.addCoins = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 11, opt_value, proto.CoinType, opt_index);
};


proto.Features.prototype.clearCoinsList = function() {
  this.setCoinsList([]);
};


/**
 * optional bool initialized = 12;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.Features.prototype.getInitialized = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 12, false));
};


/** @param {boolean} value */
proto.Features.prototype.setInitialized = function(value) {
  jspb.Message.setField(this, 12, value);
};


proto.Features.prototype.clearInitialized = function() {
  jspb.Message.setField(this, 12, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasInitialized = function() {
  return jspb.Message.getField(this, 12) != null;
};


/**
 * optional bytes revision = 13;
 * @return {!(string|Uint8Array)}
 */
proto.Features.prototype.getRevision = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 13, ""));
};


/**
 * optional bytes revision = 13;
 * This is a type-conversion wrapper around `getRevision()`
 * @return {string}
 */
proto.Features.prototype.getRevision_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getRevision()));
};


/**
 * optional bytes revision = 13;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getRevision()`
 * @return {!Uint8Array}
 */
proto.Features.prototype.getRevision_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getRevision()));
};


/** @param {!(string|Uint8Array)} value */
proto.Features.prototype.setRevision = function(value) {
  jspb.Message.setField(this, 13, value);
};


proto.Features.prototype.clearRevision = function() {
  jspb.Message.setField(this, 13, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasRevision = function() {
  return jspb.Message.getField(this, 13) != null;
};


/**
 * optional bytes bootloader_hash = 14;
 * @return {!(string|Uint8Array)}
 */
proto.Features.prototype.getBootloaderHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 14, ""));
};


/**
 * optional bytes bootloader_hash = 14;
 * This is a type-conversion wrapper around `getBootloaderHash()`
 * @return {string}
 */
proto.Features.prototype.getBootloaderHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getBootloaderHash()));
};


/**
 * optional bytes bootloader_hash = 14;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getBootloaderHash()`
 * @return {!Uint8Array}
 */
proto.Features.prototype.getBootloaderHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getBootloaderHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.Features.prototype.setBootloaderHash = function(value) {
  jspb.Message.setField(this, 14, value);
};


proto.Features.prototype.clearBootloaderHash = function() {
  jspb.Message.setField(this, 14, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasBootloaderHash = function() {
  return jspb.Message.getField(this, 14) != null;
};


/**
 * optional bool imported = 15;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.Features.prototype.getImported = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 15, false));
};


/** @param {boolean} value */
proto.Features.prototype.setImported = function(value) {
  jspb.Message.setField(this, 15, value);
};


proto.Features.prototype.clearImported = function() {
  jspb.Message.setField(this, 15, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasImported = function() {
  return jspb.Message.getField(this, 15) != null;
};


/**
 * optional bool pin_cached = 16;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.Features.prototype.getPinCached = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 16, false));
};


/** @param {boolean} value */
proto.Features.prototype.setPinCached = function(value) {
  jspb.Message.setField(this, 16, value);
};


proto.Features.prototype.clearPinCached = function() {
  jspb.Message.setField(this, 16, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasPinCached = function() {
  return jspb.Message.getField(this, 16) != null;
};


/**
 * optional bool passphrase_cached = 17;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.Features.prototype.getPassphraseCached = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 17, false));
};


/** @param {boolean} value */
proto.Features.prototype.setPassphraseCached = function(value) {
  jspb.Message.setField(this, 17, value);
};


proto.Features.prototype.clearPassphraseCached = function() {
  jspb.Message.setField(this, 17, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasPassphraseCached = function() {
  return jspb.Message.getField(this, 17) != null;
};


/**
 * repeated PolicyType policies = 18;
 * @return {!Array<!proto.PolicyType>}
 */
proto.Features.prototype.getPoliciesList = function() {
  return /** @type{!Array<!proto.PolicyType>} */ (
    jspb.Message.getRepeatedWrapperField(this, types_pb.PolicyType, 18));
};


/** @param {!Array<!proto.PolicyType>} value */
proto.Features.prototype.setPoliciesList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 18, value);
};


/**
 * @param {!proto.PolicyType=} opt_value
 * @param {number=} opt_index
 * @return {!proto.PolicyType}
 */
proto.Features.prototype.addPolicies = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 18, opt_value, proto.PolicyType, opt_index);
};


proto.Features.prototype.clearPoliciesList = function() {
  this.setPoliciesList([]);
};


/**
 * optional string model = 21;
 * @return {string}
 */
proto.Features.prototype.getModel = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 21, ""));
};


/** @param {string} value */
proto.Features.prototype.setModel = function(value) {
  jspb.Message.setField(this, 21, value);
};


proto.Features.prototype.clearModel = function() {
  jspb.Message.setField(this, 21, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasModel = function() {
  return jspb.Message.getField(this, 21) != null;
};


/**
 * optional string firmware_variant = 22;
 * @return {string}
 */
proto.Features.prototype.getFirmwareVariant = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 22, ""));
};


/** @param {string} value */
proto.Features.prototype.setFirmwareVariant = function(value) {
  jspb.Message.setField(this, 22, value);
};


proto.Features.prototype.clearFirmwareVariant = function() {
  jspb.Message.setField(this, 22, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasFirmwareVariant = function() {
  return jspb.Message.getField(this, 22) != null;
};


/**
 * optional bytes firmware_hash = 23;
 * @return {!(string|Uint8Array)}
 */
proto.Features.prototype.getFirmwareHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 23, ""));
};


/**
 * optional bytes firmware_hash = 23;
 * This is a type-conversion wrapper around `getFirmwareHash()`
 * @return {string}
 */
proto.Features.prototype.getFirmwareHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getFirmwareHash()));
};


/**
 * optional bytes firmware_hash = 23;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getFirmwareHash()`
 * @return {!Uint8Array}
 */
proto.Features.prototype.getFirmwareHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getFirmwareHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.Features.prototype.setFirmwareHash = function(value) {
  jspb.Message.setField(this, 23, value);
};


proto.Features.prototype.clearFirmwareHash = function() {
  jspb.Message.setField(this, 23, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasFirmwareHash = function() {
  return jspb.Message.getField(this, 23) != null;
};


/**
 * optional bool no_backup = 24;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.Features.prototype.getNoBackup = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 24, false));
};


/** @param {boolean} value */
proto.Features.prototype.setNoBackup = function(value) {
  jspb.Message.setField(this, 24, value);
};


proto.Features.prototype.clearNoBackup = function() {
  jspb.Message.setField(this, 24, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Features.prototype.hasNoBackup = function() {
  return jspb.Message.getField(this, 24) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.GetCoinTable = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.GetCoinTable, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.GetCoinTable.displayName = 'proto.GetCoinTable';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.GetCoinTable.prototype.toObject = function(opt_includeInstance) {
  return proto.GetCoinTable.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.GetCoinTable} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.GetCoinTable.toObject = function(includeInstance, msg) {
  var f, obj = {
    start: jspb.Message.getField(msg, 1),
    end: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.GetCoinTable}
 */
proto.GetCoinTable.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.GetCoinTable;
  return proto.GetCoinTable.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.GetCoinTable} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.GetCoinTable}
 */
proto.GetCoinTable.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setStart(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setEnd(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.GetCoinTable.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.GetCoinTable.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.GetCoinTable} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.GetCoinTable.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * optional uint32 start = 1;
 * @return {number}
 */
proto.GetCoinTable.prototype.getStart = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.GetCoinTable.prototype.setStart = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.GetCoinTable.prototype.clearStart = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.GetCoinTable.prototype.hasStart = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 end = 2;
 * @return {number}
 */
proto.GetCoinTable.prototype.getEnd = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.GetCoinTable.prototype.setEnd = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.GetCoinTable.prototype.clearEnd = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.GetCoinTable.prototype.hasEnd = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CoinTable = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.CoinTable.repeatedFields_, null);
};
goog.inherits(proto.CoinTable, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.CoinTable.displayName = 'proto.CoinTable';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.CoinTable.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CoinTable.prototype.toObject = function(opt_includeInstance) {
  return proto.CoinTable.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CoinTable} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CoinTable.toObject = function(includeInstance, msg) {
  var f, obj = {
    tableList: jspb.Message.toObjectList(msg.getTableList(),
    types_pb.CoinType.toObject, includeInstance),
    numCoins: jspb.Message.getField(msg, 2),
    chunkSize: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CoinTable}
 */
proto.CoinTable.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CoinTable;
  return proto.CoinTable.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CoinTable} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CoinTable}
 */
proto.CoinTable.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new types_pb.CoinType;
      reader.readMessage(value,types_pb.CoinType.deserializeBinaryFromReader);
      msg.addTable(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setNumCoins(value);
      break;
    case 3:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setChunkSize(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CoinTable.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CoinTable.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CoinTable} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CoinTable.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTableList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      types_pb.CoinType.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeUint32(
      3,
      f
    );
  }
};


/**
 * repeated CoinType table = 1;
 * @return {!Array<!proto.CoinType>}
 */
proto.CoinTable.prototype.getTableList = function() {
  return /** @type{!Array<!proto.CoinType>} */ (
    jspb.Message.getRepeatedWrapperField(this, types_pb.CoinType, 1));
};


/** @param {!Array<!proto.CoinType>} value */
proto.CoinTable.prototype.setTableList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.CoinType=} opt_value
 * @param {number=} opt_index
 * @return {!proto.CoinType}
 */
proto.CoinTable.prototype.addTable = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.CoinType, opt_index);
};


proto.CoinTable.prototype.clearTableList = function() {
  this.setTableList([]);
};


/**
 * optional uint32 num_coins = 2;
 * @return {number}
 */
proto.CoinTable.prototype.getNumCoins = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.CoinTable.prototype.setNumCoins = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.CoinTable.prototype.clearNumCoins = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinTable.prototype.hasNumCoins = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional uint32 chunk_size = 3;
 * @return {number}
 */
proto.CoinTable.prototype.getChunkSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 3, 0));
};


/** @param {number} value */
proto.CoinTable.prototype.setChunkSize = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.CoinTable.prototype.clearChunkSize = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CoinTable.prototype.hasChunkSize = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ClearSession = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ClearSession, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ClearSession.displayName = 'proto.ClearSession';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ClearSession.prototype.toObject = function(opt_includeInstance) {
  return proto.ClearSession.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ClearSession} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ClearSession.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ClearSession}
 */
proto.ClearSession.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ClearSession;
  return proto.ClearSession.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ClearSession} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ClearSession}
 */
proto.ClearSession.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ClearSession.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ClearSession.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ClearSession} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ClearSession.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ApplySettings = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ApplySettings, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ApplySettings.displayName = 'proto.ApplySettings';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ApplySettings.prototype.toObject = function(opt_includeInstance) {
  return proto.ApplySettings.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ApplySettings} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ApplySettings.toObject = function(includeInstance, msg) {
  var f, obj = {
    language: jspb.Message.getField(msg, 1),
    label: jspb.Message.getField(msg, 2),
    usePassphrase: jspb.Message.getField(msg, 3),
    autoLockDelayMs: jspb.Message.getField(msg, 4),
    u2fCounter: jspb.Message.getField(msg, 5)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ApplySettings}
 */
proto.ApplySettings.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ApplySettings;
  return proto.ApplySettings.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ApplySettings} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ApplySettings}
 */
proto.ApplySettings.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setLanguage(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setLabel(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setUsePassphrase(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAutoLockDelayMs(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setU2fCounter(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ApplySettings.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ApplySettings.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ApplySettings} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ApplySettings.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBool(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeUint32(
      5,
      f
    );
  }
};


/**
 * optional string language = 1;
 * @return {string}
 */
proto.ApplySettings.prototype.getLanguage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.ApplySettings.prototype.setLanguage = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.ApplySettings.prototype.clearLanguage = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ApplySettings.prototype.hasLanguage = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string label = 2;
 * @return {string}
 */
proto.ApplySettings.prototype.getLabel = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.ApplySettings.prototype.setLabel = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.ApplySettings.prototype.clearLabel = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ApplySettings.prototype.hasLabel = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bool use_passphrase = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.ApplySettings.prototype.getUsePassphrase = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.ApplySettings.prototype.setUsePassphrase = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.ApplySettings.prototype.clearUsePassphrase = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ApplySettings.prototype.hasUsePassphrase = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional uint32 auto_lock_delay_ms = 4;
 * @return {number}
 */
proto.ApplySettings.prototype.getAutoLockDelayMs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {number} value */
proto.ApplySettings.prototype.setAutoLockDelayMs = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.ApplySettings.prototype.clearAutoLockDelayMs = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ApplySettings.prototype.hasAutoLockDelayMs = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional uint32 u2f_counter = 5;
 * @return {number}
 */
proto.ApplySettings.prototype.getU2fCounter = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.ApplySettings.prototype.setU2fCounter = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.ApplySettings.prototype.clearU2fCounter = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ApplySettings.prototype.hasU2fCounter = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ChangePin = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ChangePin, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ChangePin.displayName = 'proto.ChangePin';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ChangePin.prototype.toObject = function(opt_includeInstance) {
  return proto.ChangePin.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ChangePin} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ChangePin.toObject = function(includeInstance, msg) {
  var f, obj = {
    remove: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ChangePin}
 */
proto.ChangePin.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ChangePin;
  return proto.ChangePin.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ChangePin} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ChangePin}
 */
proto.ChangePin.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setRemove(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ChangePin.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ChangePin.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ChangePin} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ChangePin.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {boolean} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * optional bool remove = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.ChangePin.prototype.getRemove = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.ChangePin.prototype.setRemove = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.ChangePin.prototype.clearRemove = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ChangePin.prototype.hasRemove = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Ping = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Ping, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.Ping.displayName = 'proto.Ping';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Ping.prototype.toObject = function(opt_includeInstance) {
  return proto.Ping.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Ping} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Ping.toObject = function(includeInstance, msg) {
  var f, obj = {
    message: jspb.Message.getField(msg, 1),
    buttonProtection: jspb.Message.getField(msg, 2),
    pinProtection: jspb.Message.getField(msg, 3),
    passphraseProtection: jspb.Message.getField(msg, 4)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Ping}
 */
proto.Ping.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Ping;
  return proto.Ping.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Ping} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Ping}
 */
proto.Ping.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setButtonProtection(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPinProtection(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPassphraseProtection(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Ping.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Ping.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Ping} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Ping.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBool(
      2,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBool(
      3,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBool(
      4,
      f
    );
  }
};


/**
 * optional string message = 1;
 * @return {string}
 */
proto.Ping.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.Ping.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.Ping.prototype.clearMessage = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Ping.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool button_protection = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.Ping.prototype.getButtonProtection = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.Ping.prototype.setButtonProtection = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.Ping.prototype.clearButtonProtection = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Ping.prototype.hasButtonProtection = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bool pin_protection = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.Ping.prototype.getPinProtection = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.Ping.prototype.setPinProtection = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.Ping.prototype.clearPinProtection = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Ping.prototype.hasPinProtection = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bool passphrase_protection = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.Ping.prototype.getPassphraseProtection = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.Ping.prototype.setPassphraseProtection = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.Ping.prototype.clearPassphraseProtection = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Ping.prototype.hasPassphraseProtection = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Success = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Success, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.Success.displayName = 'proto.Success';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Success.prototype.toObject = function(opt_includeInstance) {
  return proto.Success.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Success} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Success.toObject = function(includeInstance, msg) {
  var f, obj = {
    message: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Success}
 */
proto.Success.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Success;
  return proto.Success.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Success} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Success}
 */
proto.Success.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Success.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Success.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Success} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Success.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * optional string message = 1;
 * @return {string}
 */
proto.Success.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.Success.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.Success.prototype.clearMessage = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Success.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Failure = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Failure, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.Failure.displayName = 'proto.Failure';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Failure.prototype.toObject = function(opt_includeInstance) {
  return proto.Failure.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Failure} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Failure.toObject = function(includeInstance, msg) {
  var f, obj = {
    code: jspb.Message.getField(msg, 1),
    message: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Failure}
 */
proto.Failure.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Failure;
  return proto.Failure.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Failure} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Failure}
 */
proto.Failure.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.FailureType} */ (reader.readEnum());
      msg.setCode(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setMessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Failure.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Failure.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Failure} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Failure.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.FailureType} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional FailureType code = 1;
 * @return {!proto.FailureType}
 */
proto.Failure.prototype.getCode = function() {
  return /** @type {!proto.FailureType} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.FailureType} value */
proto.Failure.prototype.setCode = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.Failure.prototype.clearCode = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Failure.prototype.hasCode = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string message = 2;
 * @return {string}
 */
proto.Failure.prototype.getMessage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.Failure.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.Failure.prototype.clearMessage = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Failure.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ButtonRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ButtonRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ButtonRequest.displayName = 'proto.ButtonRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ButtonRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.ButtonRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ButtonRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ButtonRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    code: jspb.Message.getField(msg, 1),
    data: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ButtonRequest}
 */
proto.ButtonRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ButtonRequest;
  return proto.ButtonRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ButtonRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ButtonRequest}
 */
proto.ButtonRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.ButtonRequestType} */ (reader.readEnum());
      msg.setCode(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ButtonRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ButtonRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ButtonRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ButtonRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.ButtonRequestType} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional ButtonRequestType code = 1;
 * @return {!proto.ButtonRequestType}
 */
proto.ButtonRequest.prototype.getCode = function() {
  return /** @type {!proto.ButtonRequestType} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.ButtonRequestType} value */
proto.ButtonRequest.prototype.setCode = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.ButtonRequest.prototype.clearCode = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ButtonRequest.prototype.hasCode = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string data = 2;
 * @return {string}
 */
proto.ButtonRequest.prototype.getData = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.ButtonRequest.prototype.setData = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.ButtonRequest.prototype.clearData = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ButtonRequest.prototype.hasData = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ButtonAck = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ButtonAck, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ButtonAck.displayName = 'proto.ButtonAck';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ButtonAck.prototype.toObject = function(opt_includeInstance) {
  return proto.ButtonAck.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ButtonAck} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ButtonAck.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ButtonAck}
 */
proto.ButtonAck.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ButtonAck;
  return proto.ButtonAck.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ButtonAck} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ButtonAck}
 */
proto.ButtonAck.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ButtonAck.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ButtonAck.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ButtonAck} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ButtonAck.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.PinMatrixRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.PinMatrixRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.PinMatrixRequest.displayName = 'proto.PinMatrixRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.PinMatrixRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.PinMatrixRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.PinMatrixRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.PinMatrixRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    type: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.PinMatrixRequest}
 */
proto.PinMatrixRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.PinMatrixRequest;
  return proto.PinMatrixRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.PinMatrixRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.PinMatrixRequest}
 */
proto.PinMatrixRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.PinMatrixRequestType} */ (reader.readEnum());
      msg.setType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.PinMatrixRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.PinMatrixRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.PinMatrixRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.PinMatrixRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.PinMatrixRequestType} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
};


/**
 * optional PinMatrixRequestType type = 1;
 * @return {!proto.PinMatrixRequestType}
 */
proto.PinMatrixRequest.prototype.getType = function() {
  return /** @type {!proto.PinMatrixRequestType} */ (jspb.Message.getFieldWithDefault(this, 1, 1));
};


/** @param {!proto.PinMatrixRequestType} value */
proto.PinMatrixRequest.prototype.setType = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.PinMatrixRequest.prototype.clearType = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.PinMatrixRequest.prototype.hasType = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.PinMatrixAck = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.PinMatrixAck, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.PinMatrixAck.displayName = 'proto.PinMatrixAck';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.PinMatrixAck.prototype.toObject = function(opt_includeInstance) {
  return proto.PinMatrixAck.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.PinMatrixAck} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.PinMatrixAck.toObject = function(includeInstance, msg) {
  var f, obj = {
    pin: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.PinMatrixAck}
 */
proto.PinMatrixAck.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.PinMatrixAck;
  return proto.PinMatrixAck.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.PinMatrixAck} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.PinMatrixAck}
 */
proto.PinMatrixAck.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setPin(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.PinMatrixAck.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.PinMatrixAck.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.PinMatrixAck} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.PinMatrixAck.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * required string pin = 1;
 * @return {string}
 */
proto.PinMatrixAck.prototype.getPin = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.PinMatrixAck.prototype.setPin = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.PinMatrixAck.prototype.clearPin = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.PinMatrixAck.prototype.hasPin = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Cancel = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Cancel, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.Cancel.displayName = 'proto.Cancel';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Cancel.prototype.toObject = function(opt_includeInstance) {
  return proto.Cancel.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Cancel} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Cancel.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Cancel}
 */
proto.Cancel.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Cancel;
  return proto.Cancel.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Cancel} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Cancel}
 */
proto.Cancel.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Cancel.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Cancel.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Cancel} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Cancel.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.PassphraseRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.PassphraseRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.PassphraseRequest.displayName = 'proto.PassphraseRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.PassphraseRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.PassphraseRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.PassphraseRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.PassphraseRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.PassphraseRequest}
 */
proto.PassphraseRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.PassphraseRequest;
  return proto.PassphraseRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.PassphraseRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.PassphraseRequest}
 */
proto.PassphraseRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.PassphraseRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.PassphraseRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.PassphraseRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.PassphraseRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.PassphraseAck = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.PassphraseAck, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.PassphraseAck.displayName = 'proto.PassphraseAck';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.PassphraseAck.prototype.toObject = function(opt_includeInstance) {
  return proto.PassphraseAck.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.PassphraseAck} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.PassphraseAck.toObject = function(includeInstance, msg) {
  var f, obj = {
    passphrase: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.PassphraseAck}
 */
proto.PassphraseAck.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.PassphraseAck;
  return proto.PassphraseAck.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.PassphraseAck} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.PassphraseAck}
 */
proto.PassphraseAck.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setPassphrase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.PassphraseAck.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.PassphraseAck.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.PassphraseAck} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.PassphraseAck.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * required string passphrase = 1;
 * @return {string}
 */
proto.PassphraseAck.prototype.getPassphrase = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.PassphraseAck.prototype.setPassphrase = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.PassphraseAck.prototype.clearPassphrase = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.PassphraseAck.prototype.hasPassphrase = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.GetEntropy = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.GetEntropy, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.GetEntropy.displayName = 'proto.GetEntropy';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.GetEntropy.prototype.toObject = function(opt_includeInstance) {
  return proto.GetEntropy.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.GetEntropy} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.GetEntropy.toObject = function(includeInstance, msg) {
  var f, obj = {
    size: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.GetEntropy}
 */
proto.GetEntropy.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.GetEntropy;
  return proto.GetEntropy.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.GetEntropy} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.GetEntropy}
 */
proto.GetEntropy.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSize(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.GetEntropy.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.GetEntropy.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.GetEntropy} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.GetEntropy.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * required uint32 size = 1;
 * @return {number}
 */
proto.GetEntropy.prototype.getSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.GetEntropy.prototype.setSize = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.GetEntropy.prototype.clearSize = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.GetEntropy.prototype.hasSize = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Entropy = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Entropy, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.Entropy.displayName = 'proto.Entropy';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Entropy.prototype.toObject = function(opt_includeInstance) {
  return proto.Entropy.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Entropy} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Entropy.toObject = function(includeInstance, msg) {
  var f, obj = {
    entropy: msg.getEntropy_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Entropy}
 */
proto.Entropy.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Entropy;
  return proto.Entropy.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Entropy} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Entropy}
 */
proto.Entropy.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEntropy(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Entropy.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Entropy.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Entropy} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Entropy.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * required bytes entropy = 1;
 * @return {!(string|Uint8Array)}
 */
proto.Entropy.prototype.getEntropy = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * required bytes entropy = 1;
 * This is a type-conversion wrapper around `getEntropy()`
 * @return {string}
 */
proto.Entropy.prototype.getEntropy_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEntropy()));
};


/**
 * required bytes entropy = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEntropy()`
 * @return {!Uint8Array}
 */
proto.Entropy.prototype.getEntropy_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEntropy()));
};


/** @param {!(string|Uint8Array)} value */
proto.Entropy.prototype.setEntropy = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.Entropy.prototype.clearEntropy = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Entropy.prototype.hasEntropy = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.GetPublicKey = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.GetPublicKey.repeatedFields_, null);
};
goog.inherits(proto.GetPublicKey, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.GetPublicKey.displayName = 'proto.GetPublicKey';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.GetPublicKey.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.GetPublicKey.prototype.toObject = function(opt_includeInstance) {
  return proto.GetPublicKey.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.GetPublicKey} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.GetPublicKey.toObject = function(includeInstance, msg) {
  var f, obj = {
    addressNList: jspb.Message.getRepeatedField(msg, 1),
    ecdsaCurveName: jspb.Message.getField(msg, 2),
    showDisplay: jspb.Message.getField(msg, 3),
    coinName: jspb.Message.getFieldWithDefault(msg, 4, "Bitcoin"),
    scriptType: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.GetPublicKey}
 */
proto.GetPublicKey.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.GetPublicKey;
  return proto.GetPublicKey.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.GetPublicKey} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.GetPublicKey}
 */
proto.GetPublicKey.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addAddressN(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setEcdsaCurveName(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setShowDisplay(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setCoinName(value);
      break;
    case 5:
      var value = /** @type {!proto.InputScriptType} */ (reader.readEnum());
      msg.setScriptType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.GetPublicKey.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.GetPublicKey.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.GetPublicKey} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.GetPublicKey.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBool(
      3,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeString(
      4,
      f
    );
  }
  f = /** @type {!proto.InputScriptType} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeEnum(
      5,
      f
    );
  }
};


/**
 * repeated uint32 address_n = 1;
 * @return {!Array<number>}
 */
proto.GetPublicKey.prototype.getAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array<number>} value */
proto.GetPublicKey.prototype.setAddressNList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.GetPublicKey.prototype.addAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.GetPublicKey.prototype.clearAddressNList = function() {
  this.setAddressNList([]);
};


/**
 * optional string ecdsa_curve_name = 2;
 * @return {string}
 */
proto.GetPublicKey.prototype.getEcdsaCurveName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.GetPublicKey.prototype.setEcdsaCurveName = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.GetPublicKey.prototype.clearEcdsaCurveName = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.GetPublicKey.prototype.hasEcdsaCurveName = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bool show_display = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.GetPublicKey.prototype.getShowDisplay = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.GetPublicKey.prototype.setShowDisplay = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.GetPublicKey.prototype.clearShowDisplay = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.GetPublicKey.prototype.hasShowDisplay = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional string coin_name = 4;
 * @return {string}
 */
proto.GetPublicKey.prototype.getCoinName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, "Bitcoin"));
};


/** @param {string} value */
proto.GetPublicKey.prototype.setCoinName = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.GetPublicKey.prototype.clearCoinName = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.GetPublicKey.prototype.hasCoinName = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional InputScriptType script_type = 5;
 * @return {!proto.InputScriptType}
 */
proto.GetPublicKey.prototype.getScriptType = function() {
  return /** @type {!proto.InputScriptType} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {!proto.InputScriptType} value */
proto.GetPublicKey.prototype.setScriptType = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.GetPublicKey.prototype.clearScriptType = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.GetPublicKey.prototype.hasScriptType = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.PublicKey = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.PublicKey, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.PublicKey.displayName = 'proto.PublicKey';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.PublicKey.prototype.toObject = function(opt_includeInstance) {
  return proto.PublicKey.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.PublicKey} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.PublicKey.toObject = function(includeInstance, msg) {
  var f, obj = {
    node: (f = msg.getNode()) && types_pb.HDNodeType.toObject(includeInstance, f),
    xpub: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.PublicKey}
 */
proto.PublicKey.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.PublicKey;
  return proto.PublicKey.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.PublicKey} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.PublicKey}
 */
proto.PublicKey.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new types_pb.HDNodeType;
      reader.readMessage(value,types_pb.HDNodeType.deserializeBinaryFromReader);
      msg.setNode(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setXpub(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.PublicKey.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.PublicKey.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.PublicKey} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.PublicKey.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getNode();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      types_pb.HDNodeType.serializeBinaryToWriter
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * required HDNodeType node = 1;
 * @return {!proto.HDNodeType}
 */
proto.PublicKey.prototype.getNode = function() {
  return /** @type{!proto.HDNodeType} */ (
    jspb.Message.getWrapperField(this, types_pb.HDNodeType, 1, 1));
};


/** @param {!proto.HDNodeType} value */
proto.PublicKey.prototype.setNode = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.PublicKey.prototype.clearNode = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.PublicKey.prototype.hasNode = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string xpub = 2;
 * @return {string}
 */
proto.PublicKey.prototype.getXpub = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.PublicKey.prototype.setXpub = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.PublicKey.prototype.clearXpub = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.PublicKey.prototype.hasXpub = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.GetAddress = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.GetAddress.repeatedFields_, null);
};
goog.inherits(proto.GetAddress, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.GetAddress.displayName = 'proto.GetAddress';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.GetAddress.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.GetAddress.prototype.toObject = function(opt_includeInstance) {
  return proto.GetAddress.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.GetAddress} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.GetAddress.toObject = function(includeInstance, msg) {
  var f, obj = {
    addressNList: jspb.Message.getRepeatedField(msg, 1),
    coinName: jspb.Message.getFieldWithDefault(msg, 2, "Bitcoin"),
    showDisplay: jspb.Message.getField(msg, 3),
    multisig: (f = msg.getMultisig()) && types_pb.MultisigRedeemScriptType.toObject(includeInstance, f),
    scriptType: jspb.Message.getFieldWithDefault(msg, 5, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.GetAddress}
 */
proto.GetAddress.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.GetAddress;
  return proto.GetAddress.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.GetAddress} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.GetAddress}
 */
proto.GetAddress.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addAddressN(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setCoinName(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setShowDisplay(value);
      break;
    case 4:
      var value = new types_pb.MultisigRedeemScriptType;
      reader.readMessage(value,types_pb.MultisigRedeemScriptType.deserializeBinaryFromReader);
      msg.setMultisig(value);
      break;
    case 5:
      var value = /** @type {!proto.InputScriptType} */ (reader.readEnum());
      msg.setScriptType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.GetAddress.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.GetAddress.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.GetAddress} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.GetAddress.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getMultisig();
  if (f != null) {
    writer.writeMessage(
      4,
      f,
      types_pb.MultisigRedeemScriptType.serializeBinaryToWriter
    );
  }
  f = /** @type {!proto.InputScriptType} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeEnum(
      5,
      f
    );
  }
};


/**
 * repeated uint32 address_n = 1;
 * @return {!Array<number>}
 */
proto.GetAddress.prototype.getAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array<number>} value */
proto.GetAddress.prototype.setAddressNList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.GetAddress.prototype.addAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.GetAddress.prototype.clearAddressNList = function() {
  this.setAddressNList([]);
};


/**
 * optional string coin_name = 2;
 * @return {string}
 */
proto.GetAddress.prototype.getCoinName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, "Bitcoin"));
};


/** @param {string} value */
proto.GetAddress.prototype.setCoinName = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.GetAddress.prototype.clearCoinName = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.GetAddress.prototype.hasCoinName = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bool show_display = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.GetAddress.prototype.getShowDisplay = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.GetAddress.prototype.setShowDisplay = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.GetAddress.prototype.clearShowDisplay = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.GetAddress.prototype.hasShowDisplay = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional MultisigRedeemScriptType multisig = 4;
 * @return {?proto.MultisigRedeemScriptType}
 */
proto.GetAddress.prototype.getMultisig = function() {
  return /** @type{?proto.MultisigRedeemScriptType} */ (
    jspb.Message.getWrapperField(this, types_pb.MultisigRedeemScriptType, 4));
};


/** @param {?proto.MultisigRedeemScriptType|undefined} value */
proto.GetAddress.prototype.setMultisig = function(value) {
  jspb.Message.setWrapperField(this, 4, value);
};


proto.GetAddress.prototype.clearMultisig = function() {
  this.setMultisig(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.GetAddress.prototype.hasMultisig = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional InputScriptType script_type = 5;
 * @return {!proto.InputScriptType}
 */
proto.GetAddress.prototype.getScriptType = function() {
  return /** @type {!proto.InputScriptType} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {!proto.InputScriptType} value */
proto.GetAddress.prototype.setScriptType = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.GetAddress.prototype.clearScriptType = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.GetAddress.prototype.hasScriptType = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EthereumGetAddress = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.EthereumGetAddress.repeatedFields_, null);
};
goog.inherits(proto.EthereumGetAddress, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.EthereumGetAddress.displayName = 'proto.EthereumGetAddress';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.EthereumGetAddress.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EthereumGetAddress.prototype.toObject = function(opt_includeInstance) {
  return proto.EthereumGetAddress.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EthereumGetAddress} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumGetAddress.toObject = function(includeInstance, msg) {
  var f, obj = {
    addressNList: jspb.Message.getRepeatedField(msg, 1),
    showDisplay: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EthereumGetAddress}
 */
proto.EthereumGetAddress.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EthereumGetAddress;
  return proto.EthereumGetAddress.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EthereumGetAddress} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EthereumGetAddress}
 */
proto.EthereumGetAddress.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addAddressN(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setShowDisplay(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EthereumGetAddress.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EthereumGetAddress.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EthereumGetAddress} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumGetAddress.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      1,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBool(
      2,
      f
    );
  }
};


/**
 * repeated uint32 address_n = 1;
 * @return {!Array<number>}
 */
proto.EthereumGetAddress.prototype.getAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array<number>} value */
proto.EthereumGetAddress.prototype.setAddressNList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.EthereumGetAddress.prototype.addAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.EthereumGetAddress.prototype.clearAddressNList = function() {
  this.setAddressNList([]);
};


/**
 * optional bool show_display = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.EthereumGetAddress.prototype.getShowDisplay = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.EthereumGetAddress.prototype.setShowDisplay = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.EthereumGetAddress.prototype.clearShowDisplay = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumGetAddress.prototype.hasShowDisplay = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.Address = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.Address, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.Address.displayName = 'proto.Address';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.Address.prototype.toObject = function(opt_includeInstance) {
  return proto.Address.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.Address} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Address.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.Address}
 */
proto.Address.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.Address;
  return proto.Address.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.Address} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.Address}
 */
proto.Address.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.Address.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.Address.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.Address} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.Address.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * required string address = 1;
 * @return {string}
 */
proto.Address.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.Address.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.Address.prototype.clearAddress = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.Address.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EthereumAddress = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.EthereumAddress, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.EthereumAddress.displayName = 'proto.EthereumAddress';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EthereumAddress.prototype.toObject = function(opt_includeInstance) {
  return proto.EthereumAddress.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EthereumAddress} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumAddress.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: msg.getAddress_asB64(),
    addressStr: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EthereumAddress}
 */
proto.EthereumAddress.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EthereumAddress;
  return proto.EthereumAddress.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EthereumAddress} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EthereumAddress}
 */
proto.EthereumAddress.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddressStr(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EthereumAddress.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EthereumAddress.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EthereumAddress} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumAddress.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * required bytes address = 1;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumAddress.prototype.getAddress = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * required bytes address = 1;
 * This is a type-conversion wrapper around `getAddress()`
 * @return {string}
 */
proto.EthereumAddress.prototype.getAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAddress()));
};


/**
 * required bytes address = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAddress()`
 * @return {!Uint8Array}
 */
proto.EthereumAddress.prototype.getAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAddress()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumAddress.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.EthereumAddress.prototype.clearAddress = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumAddress.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string address_str = 2;
 * @return {string}
 */
proto.EthereumAddress.prototype.getAddressStr = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.EthereumAddress.prototype.setAddressStr = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.EthereumAddress.prototype.clearAddressStr = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumAddress.prototype.hasAddressStr = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.WipeDevice = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.WipeDevice, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.WipeDevice.displayName = 'proto.WipeDevice';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.WipeDevice.prototype.toObject = function(opt_includeInstance) {
  return proto.WipeDevice.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.WipeDevice} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.WipeDevice.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.WipeDevice}
 */
proto.WipeDevice.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.WipeDevice;
  return proto.WipeDevice.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.WipeDevice} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.WipeDevice}
 */
proto.WipeDevice.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.WipeDevice.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.WipeDevice.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.WipeDevice} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.WipeDevice.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.LoadDevice = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.LoadDevice, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.LoadDevice.displayName = 'proto.LoadDevice';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.LoadDevice.prototype.toObject = function(opt_includeInstance) {
  return proto.LoadDevice.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.LoadDevice} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.LoadDevice.toObject = function(includeInstance, msg) {
  var f, obj = {
    mnemonic: jspb.Message.getField(msg, 1),
    node: (f = msg.getNode()) && types_pb.HDNodeType.toObject(includeInstance, f),
    pin: jspb.Message.getField(msg, 3),
    passphraseProtection: jspb.Message.getField(msg, 4),
    language: jspb.Message.getFieldWithDefault(msg, 5, "english"),
    label: jspb.Message.getField(msg, 6),
    skipChecksum: jspb.Message.getField(msg, 7),
    u2fCounter: jspb.Message.getField(msg, 8)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.LoadDevice}
 */
proto.LoadDevice.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.LoadDevice;
  return proto.LoadDevice.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.LoadDevice} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.LoadDevice}
 */
proto.LoadDevice.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setMnemonic(value);
      break;
    case 2:
      var value = new types_pb.HDNodeType;
      reader.readMessage(value,types_pb.HDNodeType.deserializeBinaryFromReader);
      msg.setNode(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setPin(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPassphraseProtection(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setLanguage(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setLabel(value);
      break;
    case 7:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setSkipChecksum(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setU2fCounter(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.LoadDevice.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.LoadDevice.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.LoadDevice} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.LoadDevice.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = message.getNode();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      types_pb.HDNodeType.serializeBinaryToWriter
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBool(
      4,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeString(
      5,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeString(
      6,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeBool(
      7,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeUint32(
      8,
      f
    );
  }
};


/**
 * optional string mnemonic = 1;
 * @return {string}
 */
proto.LoadDevice.prototype.getMnemonic = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.LoadDevice.prototype.setMnemonic = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.LoadDevice.prototype.clearMnemonic = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.LoadDevice.prototype.hasMnemonic = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional HDNodeType node = 2;
 * @return {?proto.HDNodeType}
 */
proto.LoadDevice.prototype.getNode = function() {
  return /** @type{?proto.HDNodeType} */ (
    jspb.Message.getWrapperField(this, types_pb.HDNodeType, 2));
};


/** @param {?proto.HDNodeType|undefined} value */
proto.LoadDevice.prototype.setNode = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.LoadDevice.prototype.clearNode = function() {
  this.setNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.LoadDevice.prototype.hasNode = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional string pin = 3;
 * @return {string}
 */
proto.LoadDevice.prototype.getPin = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.LoadDevice.prototype.setPin = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.LoadDevice.prototype.clearPin = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.LoadDevice.prototype.hasPin = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bool passphrase_protection = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.LoadDevice.prototype.getPassphraseProtection = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.LoadDevice.prototype.setPassphraseProtection = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.LoadDevice.prototype.clearPassphraseProtection = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.LoadDevice.prototype.hasPassphraseProtection = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional string language = 5;
 * @return {string}
 */
proto.LoadDevice.prototype.getLanguage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, "english"));
};


/** @param {string} value */
proto.LoadDevice.prototype.setLanguage = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.LoadDevice.prototype.clearLanguage = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.LoadDevice.prototype.hasLanguage = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional string label = 6;
 * @return {string}
 */
proto.LoadDevice.prototype.getLabel = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/** @param {string} value */
proto.LoadDevice.prototype.setLabel = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.LoadDevice.prototype.clearLabel = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.LoadDevice.prototype.hasLabel = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional bool skip_checksum = 7;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.LoadDevice.prototype.getSkipChecksum = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 7, false));
};


/** @param {boolean} value */
proto.LoadDevice.prototype.setSkipChecksum = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.LoadDevice.prototype.clearSkipChecksum = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.LoadDevice.prototype.hasSkipChecksum = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional uint32 u2f_counter = 8;
 * @return {number}
 */
proto.LoadDevice.prototype.getU2fCounter = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.LoadDevice.prototype.setU2fCounter = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.LoadDevice.prototype.clearU2fCounter = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.LoadDevice.prototype.hasU2fCounter = function() {
  return jspb.Message.getField(this, 8) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ResetDevice = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.ResetDevice, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ResetDevice.displayName = 'proto.ResetDevice';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ResetDevice.prototype.toObject = function(opt_includeInstance) {
  return proto.ResetDevice.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ResetDevice} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ResetDevice.toObject = function(includeInstance, msg) {
  var f, obj = {
    displayRandom: jspb.Message.getField(msg, 1),
    strength: jspb.Message.getFieldWithDefault(msg, 2, 256),
    passphraseProtection: jspb.Message.getField(msg, 3),
    pinProtection: jspb.Message.getField(msg, 4),
    language: jspb.Message.getFieldWithDefault(msg, 5, "english"),
    label: jspb.Message.getField(msg, 6),
    noBackup: jspb.Message.getField(msg, 7),
    autoLockDelayMs: jspb.Message.getField(msg, 8)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ResetDevice}
 */
proto.ResetDevice.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ResetDevice;
  return proto.ResetDevice.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ResetDevice} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ResetDevice}
 */
proto.ResetDevice.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDisplayRandom(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setStrength(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPassphraseProtection(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPinProtection(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setLanguage(value);
      break;
    case 6:
      var value = /** @type {string} */ (reader.readString());
      msg.setLabel(value);
      break;
    case 7:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setNoBackup(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAutoLockDelayMs(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ResetDevice.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ResetDevice.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ResetDevice} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ResetDevice.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {boolean} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBool(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBool(
      3,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBool(
      4,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeString(
      5,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeString(
      6,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeBool(
      7,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeUint32(
      8,
      f
    );
  }
};


/**
 * optional bool display_random = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.ResetDevice.prototype.getDisplayRandom = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.ResetDevice.prototype.setDisplayRandom = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.ResetDevice.prototype.clearDisplayRandom = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ResetDevice.prototype.hasDisplayRandom = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 strength = 2;
 * @return {number}
 */
proto.ResetDevice.prototype.getStrength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 256));
};


/** @param {number} value */
proto.ResetDevice.prototype.setStrength = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.ResetDevice.prototype.clearStrength = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ResetDevice.prototype.hasStrength = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bool passphrase_protection = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.ResetDevice.prototype.getPassphraseProtection = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.ResetDevice.prototype.setPassphraseProtection = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.ResetDevice.prototype.clearPassphraseProtection = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ResetDevice.prototype.hasPassphraseProtection = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bool pin_protection = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.ResetDevice.prototype.getPinProtection = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.ResetDevice.prototype.setPinProtection = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.ResetDevice.prototype.clearPinProtection = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ResetDevice.prototype.hasPinProtection = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional string language = 5;
 * @return {string}
 */
proto.ResetDevice.prototype.getLanguage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, "english"));
};


/** @param {string} value */
proto.ResetDevice.prototype.setLanguage = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.ResetDevice.prototype.clearLanguage = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ResetDevice.prototype.hasLanguage = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional string label = 6;
 * @return {string}
 */
proto.ResetDevice.prototype.getLabel = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/** @param {string} value */
proto.ResetDevice.prototype.setLabel = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.ResetDevice.prototype.clearLabel = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ResetDevice.prototype.hasLabel = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional bool no_backup = 7;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.ResetDevice.prototype.getNoBackup = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 7, false));
};


/** @param {boolean} value */
proto.ResetDevice.prototype.setNoBackup = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.ResetDevice.prototype.clearNoBackup = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ResetDevice.prototype.hasNoBackup = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional uint32 auto_lock_delay_ms = 8;
 * @return {number}
 */
proto.ResetDevice.prototype.getAutoLockDelayMs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.ResetDevice.prototype.setAutoLockDelayMs = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.ResetDevice.prototype.clearAutoLockDelayMs = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.ResetDevice.prototype.hasAutoLockDelayMs = function() {
  return jspb.Message.getField(this, 8) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EntropyRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.EntropyRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.EntropyRequest.displayName = 'proto.EntropyRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EntropyRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.EntropyRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EntropyRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EntropyRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EntropyRequest}
 */
proto.EntropyRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EntropyRequest;
  return proto.EntropyRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EntropyRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EntropyRequest}
 */
proto.EntropyRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EntropyRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EntropyRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EntropyRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EntropyRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EntropyAck = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.EntropyAck, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.EntropyAck.displayName = 'proto.EntropyAck';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EntropyAck.prototype.toObject = function(opt_includeInstance) {
  return proto.EntropyAck.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EntropyAck} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EntropyAck.toObject = function(includeInstance, msg) {
  var f, obj = {
    entropy: msg.getEntropy_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EntropyAck}
 */
proto.EntropyAck.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EntropyAck;
  return proto.EntropyAck.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EntropyAck} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EntropyAck}
 */
proto.EntropyAck.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setEntropy(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EntropyAck.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EntropyAck.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EntropyAck} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EntropyAck.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes entropy = 1;
 * @return {!(string|Uint8Array)}
 */
proto.EntropyAck.prototype.getEntropy = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes entropy = 1;
 * This is a type-conversion wrapper around `getEntropy()`
 * @return {string}
 */
proto.EntropyAck.prototype.getEntropy_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getEntropy()));
};


/**
 * optional bytes entropy = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getEntropy()`
 * @return {!Uint8Array}
 */
proto.EntropyAck.prototype.getEntropy_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getEntropy()));
};


/** @param {!(string|Uint8Array)} value */
proto.EntropyAck.prototype.setEntropy = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.EntropyAck.prototype.clearEntropy = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EntropyAck.prototype.hasEntropy = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.RecoveryDevice = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.RecoveryDevice, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.RecoveryDevice.displayName = 'proto.RecoveryDevice';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.RecoveryDevice.prototype.toObject = function(opt_includeInstance) {
  return proto.RecoveryDevice.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.RecoveryDevice} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RecoveryDevice.toObject = function(includeInstance, msg) {
  var f, obj = {
    wordCount: jspb.Message.getField(msg, 1),
    passphraseProtection: jspb.Message.getField(msg, 2),
    pinProtection: jspb.Message.getField(msg, 3),
    language: jspb.Message.getFieldWithDefault(msg, 4, "english"),
    label: jspb.Message.getField(msg, 5),
    enforceWordlist: jspb.Message.getField(msg, 6),
    useCharacterCipher: jspb.Message.getField(msg, 7),
    autoLockDelayMs: jspb.Message.getField(msg, 8),
    u2fCounter: jspb.Message.getField(msg, 9),
    dryRun: jspb.Message.getField(msg, 10)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.RecoveryDevice}
 */
proto.RecoveryDevice.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.RecoveryDevice;
  return proto.RecoveryDevice.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.RecoveryDevice} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.RecoveryDevice}
 */
proto.RecoveryDevice.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setWordCount(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPassphraseProtection(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPinProtection(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setLanguage(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setLabel(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setEnforceWordlist(value);
      break;
    case 7:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setUseCharacterCipher(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAutoLockDelayMs(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setU2fCounter(value);
      break;
    case 10:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDryRun(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.RecoveryDevice.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.RecoveryDevice.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.RecoveryDevice} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RecoveryDevice.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBool(
      2,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBool(
      3,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeString(
      4,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeString(
      5,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeBool(
      6,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeBool(
      7,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeUint32(
      8,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeUint32(
      9,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeBool(
      10,
      f
    );
  }
};


/**
 * optional uint32 word_count = 1;
 * @return {number}
 */
proto.RecoveryDevice.prototype.getWordCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.RecoveryDevice.prototype.setWordCount = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.RecoveryDevice.prototype.clearWordCount = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.RecoveryDevice.prototype.hasWordCount = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool passphrase_protection = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.RecoveryDevice.prototype.getPassphraseProtection = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.RecoveryDevice.prototype.setPassphraseProtection = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.RecoveryDevice.prototype.clearPassphraseProtection = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.RecoveryDevice.prototype.hasPassphraseProtection = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bool pin_protection = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.RecoveryDevice.prototype.getPinProtection = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.RecoveryDevice.prototype.setPinProtection = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.RecoveryDevice.prototype.clearPinProtection = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.RecoveryDevice.prototype.hasPinProtection = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional string language = 4;
 * @return {string}
 */
proto.RecoveryDevice.prototype.getLanguage = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, "english"));
};


/** @param {string} value */
proto.RecoveryDevice.prototype.setLanguage = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.RecoveryDevice.prototype.clearLanguage = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.RecoveryDevice.prototype.hasLanguage = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional string label = 5;
 * @return {string}
 */
proto.RecoveryDevice.prototype.getLabel = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/** @param {string} value */
proto.RecoveryDevice.prototype.setLabel = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.RecoveryDevice.prototype.clearLabel = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.RecoveryDevice.prototype.hasLabel = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional bool enforce_wordlist = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.RecoveryDevice.prototype.getEnforceWordlist = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.RecoveryDevice.prototype.setEnforceWordlist = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.RecoveryDevice.prototype.clearEnforceWordlist = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.RecoveryDevice.prototype.hasEnforceWordlist = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional bool use_character_cipher = 7;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.RecoveryDevice.prototype.getUseCharacterCipher = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 7, false));
};


/** @param {boolean} value */
proto.RecoveryDevice.prototype.setUseCharacterCipher = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.RecoveryDevice.prototype.clearUseCharacterCipher = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.RecoveryDevice.prototype.hasUseCharacterCipher = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional uint32 auto_lock_delay_ms = 8;
 * @return {number}
 */
proto.RecoveryDevice.prototype.getAutoLockDelayMs = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.RecoveryDevice.prototype.setAutoLockDelayMs = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.RecoveryDevice.prototype.clearAutoLockDelayMs = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.RecoveryDevice.prototype.hasAutoLockDelayMs = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional uint32 u2f_counter = 9;
 * @return {number}
 */
proto.RecoveryDevice.prototype.getU2fCounter = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 9, 0));
};


/** @param {number} value */
proto.RecoveryDevice.prototype.setU2fCounter = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.RecoveryDevice.prototype.clearU2fCounter = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.RecoveryDevice.prototype.hasU2fCounter = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional bool dry_run = 10;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.RecoveryDevice.prototype.getDryRun = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 10, false));
};


/** @param {boolean} value */
proto.RecoveryDevice.prototype.setDryRun = function(value) {
  jspb.Message.setField(this, 10, value);
};


proto.RecoveryDevice.prototype.clearDryRun = function() {
  jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.RecoveryDevice.prototype.hasDryRun = function() {
  return jspb.Message.getField(this, 10) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.WordRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.WordRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.WordRequest.displayName = 'proto.WordRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.WordRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.WordRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.WordRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.WordRequest.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.WordRequest}
 */
proto.WordRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.WordRequest;
  return proto.WordRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.WordRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.WordRequest}
 */
proto.WordRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.WordRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.WordRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.WordRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.WordRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.WordAck = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.WordAck, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.WordAck.displayName = 'proto.WordAck';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.WordAck.prototype.toObject = function(opt_includeInstance) {
  return proto.WordAck.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.WordAck} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.WordAck.toObject = function(includeInstance, msg) {
  var f, obj = {
    word: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.WordAck}
 */
proto.WordAck.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.WordAck;
  return proto.WordAck.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.WordAck} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.WordAck}
 */
proto.WordAck.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setWord(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.WordAck.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.WordAck.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.WordAck} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.WordAck.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
};


/**
 * required string word = 1;
 * @return {string}
 */
proto.WordAck.prototype.getWord = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.WordAck.prototype.setWord = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.WordAck.prototype.clearWord = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.WordAck.prototype.hasWord = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CharacterRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CharacterRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.CharacterRequest.displayName = 'proto.CharacterRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CharacterRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.CharacterRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CharacterRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CharacterRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    wordPos: jspb.Message.getField(msg, 1),
    characterPos: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CharacterRequest}
 */
proto.CharacterRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CharacterRequest;
  return proto.CharacterRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CharacterRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CharacterRequest}
 */
proto.CharacterRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setWordPos(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setCharacterPos(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CharacterRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CharacterRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CharacterRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CharacterRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * required uint32 word_pos = 1;
 * @return {number}
 */
proto.CharacterRequest.prototype.getWordPos = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.CharacterRequest.prototype.setWordPos = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.CharacterRequest.prototype.clearWordPos = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CharacterRequest.prototype.hasWordPos = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required uint32 character_pos = 2;
 * @return {number}
 */
proto.CharacterRequest.prototype.getCharacterPos = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.CharacterRequest.prototype.setCharacterPos = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.CharacterRequest.prototype.clearCharacterPos = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CharacterRequest.prototype.hasCharacterPos = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CharacterAck = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CharacterAck, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.CharacterAck.displayName = 'proto.CharacterAck';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CharacterAck.prototype.toObject = function(opt_includeInstance) {
  return proto.CharacterAck.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CharacterAck} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CharacterAck.toObject = function(includeInstance, msg) {
  var f, obj = {
    character: jspb.Message.getField(msg, 1),
    pb_delete: jspb.Message.getField(msg, 2),
    done: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CharacterAck}
 */
proto.CharacterAck.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CharacterAck;
  return proto.CharacterAck.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CharacterAck} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CharacterAck}
 */
proto.CharacterAck.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setCharacter(value);
      break;
    case 2:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDelete(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDone(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CharacterAck.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CharacterAck.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CharacterAck} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CharacterAck.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBool(
      2,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBool(
      3,
      f
    );
  }
};


/**
 * optional string character = 1;
 * @return {string}
 */
proto.CharacterAck.prototype.getCharacter = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.CharacterAck.prototype.setCharacter = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.CharacterAck.prototype.clearCharacter = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CharacterAck.prototype.hasCharacter = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bool delete = 2;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.CharacterAck.prototype.getDelete = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 2, false));
};


/** @param {boolean} value */
proto.CharacterAck.prototype.setDelete = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.CharacterAck.prototype.clearDelete = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CharacterAck.prototype.hasDelete = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bool done = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.CharacterAck.prototype.getDone = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.CharacterAck.prototype.setDone = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.CharacterAck.prototype.clearDone = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CharacterAck.prototype.hasDone = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SignMessage = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.SignMessage.repeatedFields_, null);
};
goog.inherits(proto.SignMessage, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SignMessage.displayName = 'proto.SignMessage';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.SignMessage.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SignMessage.prototype.toObject = function(opt_includeInstance) {
  return proto.SignMessage.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SignMessage} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SignMessage.toObject = function(includeInstance, msg) {
  var f, obj = {
    addressNList: jspb.Message.getRepeatedField(msg, 1),
    message: msg.getMessage_asB64(),
    coinName: jspb.Message.getFieldWithDefault(msg, 3, "Bitcoin"),
    scriptType: jspb.Message.getFieldWithDefault(msg, 4, 0)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SignMessage}
 */
proto.SignMessage.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SignMessage;
  return proto.SignMessage.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SignMessage} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SignMessage}
 */
proto.SignMessage.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addAddressN(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMessage(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setCoinName(value);
      break;
    case 4:
      var value = /** @type {!proto.InputScriptType} */ (reader.readEnum());
      msg.setScriptType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SignMessage.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SignMessage.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SignMessage} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SignMessage.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {!proto.InputScriptType} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeEnum(
      4,
      f
    );
  }
};


/**
 * repeated uint32 address_n = 1;
 * @return {!Array<number>}
 */
proto.SignMessage.prototype.getAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array<number>} value */
proto.SignMessage.prototype.setAddressNList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.SignMessage.prototype.addAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.SignMessage.prototype.clearAddressNList = function() {
  this.setAddressNList([]);
};


/**
 * required bytes message = 2;
 * @return {!(string|Uint8Array)}
 */
proto.SignMessage.prototype.getMessage = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * required bytes message = 2;
 * This is a type-conversion wrapper around `getMessage()`
 * @return {string}
 */
proto.SignMessage.prototype.getMessage_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMessage()));
};


/**
 * required bytes message = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMessage()`
 * @return {!Uint8Array}
 */
proto.SignMessage.prototype.getMessage_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMessage()));
};


/** @param {!(string|Uint8Array)} value */
proto.SignMessage.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SignMessage.prototype.clearMessage = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignMessage.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional string coin_name = 3;
 * @return {string}
 */
proto.SignMessage.prototype.getCoinName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, "Bitcoin"));
};


/** @param {string} value */
proto.SignMessage.prototype.setCoinName = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SignMessage.prototype.clearCoinName = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignMessage.prototype.hasCoinName = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional InputScriptType script_type = 4;
 * @return {!proto.InputScriptType}
 */
proto.SignMessage.prototype.getScriptType = function() {
  return /** @type {!proto.InputScriptType} */ (jspb.Message.getFieldWithDefault(this, 4, 0));
};


/** @param {!proto.InputScriptType} value */
proto.SignMessage.prototype.setScriptType = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SignMessage.prototype.clearScriptType = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignMessage.prototype.hasScriptType = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.VerifyMessage = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.VerifyMessage, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.VerifyMessage.displayName = 'proto.VerifyMessage';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.VerifyMessage.prototype.toObject = function(opt_includeInstance) {
  return proto.VerifyMessage.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.VerifyMessage} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.VerifyMessage.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getField(msg, 1),
    signature: msg.getSignature_asB64(),
    message: msg.getMessage_asB64(),
    coinName: jspb.Message.getFieldWithDefault(msg, 4, "Bitcoin")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.VerifyMessage}
 */
proto.VerifyMessage.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.VerifyMessage;
  return proto.VerifyMessage.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.VerifyMessage} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.VerifyMessage}
 */
proto.VerifyMessage.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMessage(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setCoinName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.VerifyMessage.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.VerifyMessage.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.VerifyMessage} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.VerifyMessage.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeString(
      4,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.VerifyMessage.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.VerifyMessage.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.VerifyMessage.prototype.clearAddress = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.VerifyMessage.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes signature = 2;
 * @return {!(string|Uint8Array)}
 */
proto.VerifyMessage.prototype.getSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes signature = 2;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.VerifyMessage.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.VerifyMessage.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value */
proto.VerifyMessage.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.VerifyMessage.prototype.clearSignature = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.VerifyMessage.prototype.hasSignature = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes message = 3;
 * @return {!(string|Uint8Array)}
 */
proto.VerifyMessage.prototype.getMessage = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes message = 3;
 * This is a type-conversion wrapper around `getMessage()`
 * @return {string}
 */
proto.VerifyMessage.prototype.getMessage_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMessage()));
};


/**
 * optional bytes message = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMessage()`
 * @return {!Uint8Array}
 */
proto.VerifyMessage.prototype.getMessage_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMessage()));
};


/** @param {!(string|Uint8Array)} value */
proto.VerifyMessage.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.VerifyMessage.prototype.clearMessage = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.VerifyMessage.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional string coin_name = 4;
 * @return {string}
 */
proto.VerifyMessage.prototype.getCoinName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, "Bitcoin"));
};


/** @param {string} value */
proto.VerifyMessage.prototype.setCoinName = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.VerifyMessage.prototype.clearCoinName = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.VerifyMessage.prototype.hasCoinName = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.MessageSignature = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.MessageSignature, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.MessageSignature.displayName = 'proto.MessageSignature';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.MessageSignature.prototype.toObject = function(opt_includeInstance) {
  return proto.MessageSignature.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.MessageSignature} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.MessageSignature.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getField(msg, 1),
    signature: msg.getSignature_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.MessageSignature}
 */
proto.MessageSignature.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.MessageSignature;
  return proto.MessageSignature.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.MessageSignature} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.MessageSignature}
 */
proto.MessageSignature.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.MessageSignature.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.MessageSignature.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.MessageSignature} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.MessageSignature.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.MessageSignature.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.MessageSignature.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.MessageSignature.prototype.clearAddress = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.MessageSignature.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes signature = 2;
 * @return {!(string|Uint8Array)}
 */
proto.MessageSignature.prototype.getSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes signature = 2;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.MessageSignature.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.MessageSignature.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value */
proto.MessageSignature.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.MessageSignature.prototype.clearSignature = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.MessageSignature.prototype.hasSignature = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EncryptMessage = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.EncryptMessage.repeatedFields_, null);
};
goog.inherits(proto.EncryptMessage, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.EncryptMessage.displayName = 'proto.EncryptMessage';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.EncryptMessage.repeatedFields_ = [4];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EncryptMessage.prototype.toObject = function(opt_includeInstance) {
  return proto.EncryptMessage.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EncryptMessage} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EncryptMessage.toObject = function(includeInstance, msg) {
  var f, obj = {
    pubkey: msg.getPubkey_asB64(),
    message: msg.getMessage_asB64(),
    displayOnly: jspb.Message.getField(msg, 3),
    addressNList: jspb.Message.getRepeatedField(msg, 4),
    coinName: jspb.Message.getFieldWithDefault(msg, 5, "Bitcoin")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EncryptMessage}
 */
proto.EncryptMessage.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EncryptMessage;
  return proto.EncryptMessage.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EncryptMessage} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EncryptMessage}
 */
proto.EncryptMessage.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPubkey(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMessage(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setDisplayOnly(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addAddressN(value);
      break;
    case 5:
      var value = /** @type {string} */ (reader.readString());
      msg.setCoinName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EncryptMessage.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EncryptMessage.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EncryptMessage} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EncryptMessage.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBool(
      3,
      f
    );
  }
  f = message.getAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      4,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeString(
      5,
      f
    );
  }
};


/**
 * optional bytes pubkey = 1;
 * @return {!(string|Uint8Array)}
 */
proto.EncryptMessage.prototype.getPubkey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes pubkey = 1;
 * This is a type-conversion wrapper around `getPubkey()`
 * @return {string}
 */
proto.EncryptMessage.prototype.getPubkey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPubkey()));
};


/**
 * optional bytes pubkey = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPubkey()`
 * @return {!Uint8Array}
 */
proto.EncryptMessage.prototype.getPubkey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPubkey()));
};


/** @param {!(string|Uint8Array)} value */
proto.EncryptMessage.prototype.setPubkey = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.EncryptMessage.prototype.clearPubkey = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EncryptMessage.prototype.hasPubkey = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes message = 2;
 * @return {!(string|Uint8Array)}
 */
proto.EncryptMessage.prototype.getMessage = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes message = 2;
 * This is a type-conversion wrapper around `getMessage()`
 * @return {string}
 */
proto.EncryptMessage.prototype.getMessage_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMessage()));
};


/**
 * optional bytes message = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMessage()`
 * @return {!Uint8Array}
 */
proto.EncryptMessage.prototype.getMessage_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMessage()));
};


/** @param {!(string|Uint8Array)} value */
proto.EncryptMessage.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.EncryptMessage.prototype.clearMessage = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EncryptMessage.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bool display_only = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.EncryptMessage.prototype.getDisplayOnly = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.EncryptMessage.prototype.setDisplayOnly = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.EncryptMessage.prototype.clearDisplayOnly = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EncryptMessage.prototype.hasDisplayOnly = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * repeated uint32 address_n = 4;
 * @return {!Array<number>}
 */
proto.EncryptMessage.prototype.getAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 4));
};


/** @param {!Array<number>} value */
proto.EncryptMessage.prototype.setAddressNList = function(value) {
  jspb.Message.setField(this, 4, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.EncryptMessage.prototype.addAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 4, value, opt_index);
};


proto.EncryptMessage.prototype.clearAddressNList = function() {
  this.setAddressNList([]);
};


/**
 * optional string coin_name = 5;
 * @return {string}
 */
proto.EncryptMessage.prototype.getCoinName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 5, "Bitcoin"));
};


/** @param {string} value */
proto.EncryptMessage.prototype.setCoinName = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.EncryptMessage.prototype.clearCoinName = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EncryptMessage.prototype.hasCoinName = function() {
  return jspb.Message.getField(this, 5) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EncryptedMessage = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.EncryptedMessage, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.EncryptedMessage.displayName = 'proto.EncryptedMessage';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EncryptedMessage.prototype.toObject = function(opt_includeInstance) {
  return proto.EncryptedMessage.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EncryptedMessage} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EncryptedMessage.toObject = function(includeInstance, msg) {
  var f, obj = {
    nonce: msg.getNonce_asB64(),
    message: msg.getMessage_asB64(),
    hmac: msg.getHmac_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EncryptedMessage}
 */
proto.EncryptedMessage.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EncryptedMessage;
  return proto.EncryptedMessage.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EncryptedMessage} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EncryptedMessage}
 */
proto.EncryptedMessage.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setNonce(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMessage(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHmac(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EncryptedMessage.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EncryptedMessage.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EncryptedMessage} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EncryptedMessage.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional bytes nonce = 1;
 * @return {!(string|Uint8Array)}
 */
proto.EncryptedMessage.prototype.getNonce = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes nonce = 1;
 * This is a type-conversion wrapper around `getNonce()`
 * @return {string}
 */
proto.EncryptedMessage.prototype.getNonce_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getNonce()));
};


/**
 * optional bytes nonce = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getNonce()`
 * @return {!Uint8Array}
 */
proto.EncryptedMessage.prototype.getNonce_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getNonce()));
};


/** @param {!(string|Uint8Array)} value */
proto.EncryptedMessage.prototype.setNonce = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.EncryptedMessage.prototype.clearNonce = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EncryptedMessage.prototype.hasNonce = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes message = 2;
 * @return {!(string|Uint8Array)}
 */
proto.EncryptedMessage.prototype.getMessage = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes message = 2;
 * This is a type-conversion wrapper around `getMessage()`
 * @return {string}
 */
proto.EncryptedMessage.prototype.getMessage_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMessage()));
};


/**
 * optional bytes message = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMessage()`
 * @return {!Uint8Array}
 */
proto.EncryptedMessage.prototype.getMessage_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMessage()));
};


/** @param {!(string|Uint8Array)} value */
proto.EncryptedMessage.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.EncryptedMessage.prototype.clearMessage = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EncryptedMessage.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes hmac = 3;
 * @return {!(string|Uint8Array)}
 */
proto.EncryptedMessage.prototype.getHmac = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes hmac = 3;
 * This is a type-conversion wrapper around `getHmac()`
 * @return {string}
 */
proto.EncryptedMessage.prototype.getHmac_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHmac()));
};


/**
 * optional bytes hmac = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHmac()`
 * @return {!Uint8Array}
 */
proto.EncryptedMessage.prototype.getHmac_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHmac()));
};


/** @param {!(string|Uint8Array)} value */
proto.EncryptedMessage.prototype.setHmac = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.EncryptedMessage.prototype.clearHmac = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EncryptedMessage.prototype.hasHmac = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.DecryptMessage = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.DecryptMessage.repeatedFields_, null);
};
goog.inherits(proto.DecryptMessage, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.DecryptMessage.displayName = 'proto.DecryptMessage';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.DecryptMessage.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.DecryptMessage.prototype.toObject = function(opt_includeInstance) {
  return proto.DecryptMessage.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.DecryptMessage} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DecryptMessage.toObject = function(includeInstance, msg) {
  var f, obj = {
    addressNList: jspb.Message.getRepeatedField(msg, 1),
    nonce: msg.getNonce_asB64(),
    message: msg.getMessage_asB64(),
    hmac: msg.getHmac_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.DecryptMessage}
 */
proto.DecryptMessage.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.DecryptMessage;
  return proto.DecryptMessage.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.DecryptMessage} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.DecryptMessage}
 */
proto.DecryptMessage.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addAddressN(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setNonce(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMessage(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHmac(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.DecryptMessage.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.DecryptMessage.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.DecryptMessage} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DecryptMessage.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBytes(
      4,
      f
    );
  }
};


/**
 * repeated uint32 address_n = 1;
 * @return {!Array<number>}
 */
proto.DecryptMessage.prototype.getAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array<number>} value */
proto.DecryptMessage.prototype.setAddressNList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.DecryptMessage.prototype.addAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.DecryptMessage.prototype.clearAddressNList = function() {
  this.setAddressNList([]);
};


/**
 * optional bytes nonce = 2;
 * @return {!(string|Uint8Array)}
 */
proto.DecryptMessage.prototype.getNonce = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes nonce = 2;
 * This is a type-conversion wrapper around `getNonce()`
 * @return {string}
 */
proto.DecryptMessage.prototype.getNonce_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getNonce()));
};


/**
 * optional bytes nonce = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getNonce()`
 * @return {!Uint8Array}
 */
proto.DecryptMessage.prototype.getNonce_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getNonce()));
};


/** @param {!(string|Uint8Array)} value */
proto.DecryptMessage.prototype.setNonce = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.DecryptMessage.prototype.clearNonce = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DecryptMessage.prototype.hasNonce = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes message = 3;
 * @return {!(string|Uint8Array)}
 */
proto.DecryptMessage.prototype.getMessage = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes message = 3;
 * This is a type-conversion wrapper around `getMessage()`
 * @return {string}
 */
proto.DecryptMessage.prototype.getMessage_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMessage()));
};


/**
 * optional bytes message = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMessage()`
 * @return {!Uint8Array}
 */
proto.DecryptMessage.prototype.getMessage_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMessage()));
};


/** @param {!(string|Uint8Array)} value */
proto.DecryptMessage.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.DecryptMessage.prototype.clearMessage = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DecryptMessage.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bytes hmac = 4;
 * @return {!(string|Uint8Array)}
 */
proto.DecryptMessage.prototype.getHmac = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes hmac = 4;
 * This is a type-conversion wrapper around `getHmac()`
 * @return {string}
 */
proto.DecryptMessage.prototype.getHmac_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHmac()));
};


/**
 * optional bytes hmac = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHmac()`
 * @return {!Uint8Array}
 */
proto.DecryptMessage.prototype.getHmac_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHmac()));
};


/** @param {!(string|Uint8Array)} value */
proto.DecryptMessage.prototype.setHmac = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.DecryptMessage.prototype.clearHmac = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DecryptMessage.prototype.hasHmac = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.DecryptedMessage = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.DecryptedMessage, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.DecryptedMessage.displayName = 'proto.DecryptedMessage';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.DecryptedMessage.prototype.toObject = function(opt_includeInstance) {
  return proto.DecryptedMessage.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.DecryptedMessage} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DecryptedMessage.toObject = function(includeInstance, msg) {
  var f, obj = {
    message: msg.getMessage_asB64(),
    address: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.DecryptedMessage}
 */
proto.DecryptedMessage.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.DecryptedMessage;
  return proto.DecryptedMessage.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.DecryptedMessage} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.DecryptedMessage}
 */
proto.DecryptedMessage.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMessage(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.DecryptedMessage.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.DecryptedMessage.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.DecryptedMessage} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DecryptedMessage.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
};


/**
 * optional bytes message = 1;
 * @return {!(string|Uint8Array)}
 */
proto.DecryptedMessage.prototype.getMessage = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes message = 1;
 * This is a type-conversion wrapper around `getMessage()`
 * @return {string}
 */
proto.DecryptedMessage.prototype.getMessage_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMessage()));
};


/**
 * optional bytes message = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMessage()`
 * @return {!Uint8Array}
 */
proto.DecryptedMessage.prototype.getMessage_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMessage()));
};


/** @param {!(string|Uint8Array)} value */
proto.DecryptedMessage.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.DecryptedMessage.prototype.clearMessage = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DecryptedMessage.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string address = 2;
 * @return {string}
 */
proto.DecryptedMessage.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.DecryptedMessage.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.DecryptedMessage.prototype.clearAddress = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DecryptedMessage.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CipherKeyValue = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.CipherKeyValue.repeatedFields_, null);
};
goog.inherits(proto.CipherKeyValue, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.CipherKeyValue.displayName = 'proto.CipherKeyValue';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.CipherKeyValue.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CipherKeyValue.prototype.toObject = function(opt_includeInstance) {
  return proto.CipherKeyValue.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CipherKeyValue} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CipherKeyValue.toObject = function(includeInstance, msg) {
  var f, obj = {
    addressNList: jspb.Message.getRepeatedField(msg, 1),
    key: jspb.Message.getField(msg, 2),
    value: msg.getValue_asB64(),
    encrypt: jspb.Message.getField(msg, 4),
    askOnEncrypt: jspb.Message.getField(msg, 5),
    askOnDecrypt: jspb.Message.getField(msg, 6),
    iv: msg.getIv_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CipherKeyValue}
 */
proto.CipherKeyValue.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CipherKeyValue;
  return proto.CipherKeyValue.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CipherKeyValue} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CipherKeyValue}
 */
proto.CipherKeyValue.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addAddressN(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setKey(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    case 4:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setEncrypt(value);
      break;
    case 5:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAskOnEncrypt(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setAskOnDecrypt(value);
      break;
    case 7:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setIv(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CipherKeyValue.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CipherKeyValue.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CipherKeyValue} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CipherKeyValue.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBool(
      4,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeBool(
      5,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeBool(
      6,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeBytes(
      7,
      f
    );
  }
};


/**
 * repeated uint32 address_n = 1;
 * @return {!Array<number>}
 */
proto.CipherKeyValue.prototype.getAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array<number>} value */
proto.CipherKeyValue.prototype.setAddressNList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.CipherKeyValue.prototype.addAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.CipherKeyValue.prototype.clearAddressNList = function() {
  this.setAddressNList([]);
};


/**
 * optional string key = 2;
 * @return {string}
 */
proto.CipherKeyValue.prototype.getKey = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.CipherKeyValue.prototype.setKey = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.CipherKeyValue.prototype.clearKey = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CipherKeyValue.prototype.hasKey = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes value = 3;
 * @return {!(string|Uint8Array)}
 */
proto.CipherKeyValue.prototype.getValue = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes value = 3;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.CipherKeyValue.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.CipherKeyValue.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/** @param {!(string|Uint8Array)} value */
proto.CipherKeyValue.prototype.setValue = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.CipherKeyValue.prototype.clearValue = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CipherKeyValue.prototype.hasValue = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bool encrypt = 4;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.CipherKeyValue.prototype.getEncrypt = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 4, false));
};


/** @param {boolean} value */
proto.CipherKeyValue.prototype.setEncrypt = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.CipherKeyValue.prototype.clearEncrypt = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CipherKeyValue.prototype.hasEncrypt = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional bool ask_on_encrypt = 5;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.CipherKeyValue.prototype.getAskOnEncrypt = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 5, false));
};


/** @param {boolean} value */
proto.CipherKeyValue.prototype.setAskOnEncrypt = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.CipherKeyValue.prototype.clearAskOnEncrypt = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CipherKeyValue.prototype.hasAskOnEncrypt = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional bool ask_on_decrypt = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.CipherKeyValue.prototype.getAskOnDecrypt = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.CipherKeyValue.prototype.setAskOnDecrypt = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.CipherKeyValue.prototype.clearAskOnDecrypt = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CipherKeyValue.prototype.hasAskOnDecrypt = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional bytes iv = 7;
 * @return {!(string|Uint8Array)}
 */
proto.CipherKeyValue.prototype.getIv = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * optional bytes iv = 7;
 * This is a type-conversion wrapper around `getIv()`
 * @return {string}
 */
proto.CipherKeyValue.prototype.getIv_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getIv()));
};


/**
 * optional bytes iv = 7;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getIv()`
 * @return {!Uint8Array}
 */
proto.CipherKeyValue.prototype.getIv_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getIv()));
};


/** @param {!(string|Uint8Array)} value */
proto.CipherKeyValue.prototype.setIv = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.CipherKeyValue.prototype.clearIv = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CipherKeyValue.prototype.hasIv = function() {
  return jspb.Message.getField(this, 7) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.CipheredKeyValue = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.CipheredKeyValue, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.CipheredKeyValue.displayName = 'proto.CipheredKeyValue';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.CipheredKeyValue.prototype.toObject = function(opt_includeInstance) {
  return proto.CipheredKeyValue.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.CipheredKeyValue} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CipheredKeyValue.toObject = function(includeInstance, msg) {
  var f, obj = {
    value: msg.getValue_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.CipheredKeyValue}
 */
proto.CipheredKeyValue.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.CipheredKeyValue;
  return proto.CipheredKeyValue.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.CipheredKeyValue} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.CipheredKeyValue}
 */
proto.CipheredKeyValue.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.CipheredKeyValue.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.CipheredKeyValue.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.CipheredKeyValue} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.CipheredKeyValue.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes value = 1;
 * @return {!(string|Uint8Array)}
 */
proto.CipheredKeyValue.prototype.getValue = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes value = 1;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.CipheredKeyValue.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.CipheredKeyValue.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/** @param {!(string|Uint8Array)} value */
proto.CipheredKeyValue.prototype.setValue = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.CipheredKeyValue.prototype.clearValue = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.CipheredKeyValue.prototype.hasValue = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EstimateTxSize = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.EstimateTxSize, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.EstimateTxSize.displayName = 'proto.EstimateTxSize';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EstimateTxSize.prototype.toObject = function(opt_includeInstance) {
  return proto.EstimateTxSize.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EstimateTxSize} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EstimateTxSize.toObject = function(includeInstance, msg) {
  var f, obj = {
    outputsCount: jspb.Message.getField(msg, 1),
    inputsCount: jspb.Message.getField(msg, 2),
    coinName: jspb.Message.getFieldWithDefault(msg, 3, "Bitcoin")
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EstimateTxSize}
 */
proto.EstimateTxSize.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EstimateTxSize;
  return proto.EstimateTxSize.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EstimateTxSize} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EstimateTxSize}
 */
proto.EstimateTxSize.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputsCount(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setInputsCount(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setCoinName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EstimateTxSize.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EstimateTxSize.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EstimateTxSize} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EstimateTxSize.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * required uint32 outputs_count = 1;
 * @return {number}
 */
proto.EstimateTxSize.prototype.getOutputsCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.EstimateTxSize.prototype.setOutputsCount = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.EstimateTxSize.prototype.clearOutputsCount = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EstimateTxSize.prototype.hasOutputsCount = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required uint32 inputs_count = 2;
 * @return {number}
 */
proto.EstimateTxSize.prototype.getInputsCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.EstimateTxSize.prototype.setInputsCount = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.EstimateTxSize.prototype.clearInputsCount = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EstimateTxSize.prototype.hasInputsCount = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional string coin_name = 3;
 * @return {string}
 */
proto.EstimateTxSize.prototype.getCoinName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, "Bitcoin"));
};


/** @param {string} value */
proto.EstimateTxSize.prototype.setCoinName = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.EstimateTxSize.prototype.clearCoinName = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EstimateTxSize.prototype.hasCoinName = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TxSize = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.TxSize, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.TxSize.displayName = 'proto.TxSize';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TxSize.prototype.toObject = function(opt_includeInstance) {
  return proto.TxSize.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TxSize} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxSize.toObject = function(includeInstance, msg) {
  var f, obj = {
    txSize: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TxSize}
 */
proto.TxSize.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TxSize;
  return proto.TxSize.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TxSize} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TxSize}
 */
proto.TxSize.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setTxSize(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TxSize.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TxSize.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TxSize} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxSize.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
};


/**
 * optional uint32 tx_size = 1;
 * @return {number}
 */
proto.TxSize.prototype.getTxSize = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.TxSize.prototype.setTxSize = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.TxSize.prototype.clearTxSize = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxSize.prototype.hasTxSize = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SignTx = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SignTx, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SignTx.displayName = 'proto.SignTx';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SignTx.prototype.toObject = function(opt_includeInstance) {
  return proto.SignTx.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SignTx} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SignTx.toObject = function(includeInstance, msg) {
  var f, obj = {
    outputsCount: jspb.Message.getField(msg, 1),
    inputsCount: jspb.Message.getField(msg, 2),
    coinName: jspb.Message.getFieldWithDefault(msg, 3, "Bitcoin"),
    version: jspb.Message.getFieldWithDefault(msg, 4, 1),
    lockTime: jspb.Message.getFieldWithDefault(msg, 5, 0),
    expiry: jspb.Message.getField(msg, 6),
    overwintered: jspb.Message.getField(msg, 7),
    versionGroupId: jspb.Message.getField(msg, 8)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SignTx}
 */
proto.SignTx.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SignTx;
  return proto.SignTx.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SignTx} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SignTx}
 */
proto.SignTx.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setOutputsCount(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setInputsCount(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setCoinName(value);
      break;
    case 4:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVersion(value);
      break;
    case 5:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLockTime(value);
      break;
    case 6:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setExpiry(value);
      break;
    case 7:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setOverwintered(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setVersionGroupId(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SignTx.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SignTx.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SignTx} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SignTx.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeUint32(
      4,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeUint32(
      5,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeUint32(
      6,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeBool(
      7,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeUint32(
      8,
      f
    );
  }
};


/**
 * required uint32 outputs_count = 1;
 * @return {number}
 */
proto.SignTx.prototype.getOutputsCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.SignTx.prototype.setOutputsCount = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SignTx.prototype.clearOutputsCount = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignTx.prototype.hasOutputsCount = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required uint32 inputs_count = 2;
 * @return {number}
 */
proto.SignTx.prototype.getInputsCount = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.SignTx.prototype.setInputsCount = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SignTx.prototype.clearInputsCount = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignTx.prototype.hasInputsCount = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional string coin_name = 3;
 * @return {string}
 */
proto.SignTx.prototype.getCoinName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, "Bitcoin"));
};


/** @param {string} value */
proto.SignTx.prototype.setCoinName = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SignTx.prototype.clearCoinName = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignTx.prototype.hasCoinName = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional uint32 version = 4;
 * @return {number}
 */
proto.SignTx.prototype.getVersion = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 4, 1));
};


/** @param {number} value */
proto.SignTx.prototype.setVersion = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SignTx.prototype.clearVersion = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignTx.prototype.hasVersion = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional uint32 lock_time = 5;
 * @return {number}
 */
proto.SignTx.prototype.getLockTime = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 5, 0));
};


/** @param {number} value */
proto.SignTx.prototype.setLockTime = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.SignTx.prototype.clearLockTime = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignTx.prototype.hasLockTime = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional uint32 expiry = 6;
 * @return {number}
 */
proto.SignTx.prototype.getExpiry = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 6, 0));
};


/** @param {number} value */
proto.SignTx.prototype.setExpiry = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.SignTx.prototype.clearExpiry = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignTx.prototype.hasExpiry = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional bool overwintered = 7;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.SignTx.prototype.getOverwintered = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 7, false));
};


/** @param {boolean} value */
proto.SignTx.prototype.setOverwintered = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.SignTx.prototype.clearOverwintered = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignTx.prototype.hasOverwintered = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional uint32 version_group_id = 8;
 * @return {number}
 */
proto.SignTx.prototype.getVersionGroupId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.SignTx.prototype.setVersionGroupId = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.SignTx.prototype.clearVersionGroupId = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignTx.prototype.hasVersionGroupId = function() {
  return jspb.Message.getField(this, 8) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TxRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.TxRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.TxRequest.displayName = 'proto.TxRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TxRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.TxRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TxRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    requestType: jspb.Message.getField(msg, 1),
    details: (f = msg.getDetails()) && types_pb.TxRequestDetailsType.toObject(includeInstance, f),
    serialized: (f = msg.getSerialized()) && types_pb.TxRequestSerializedType.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TxRequest}
 */
proto.TxRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TxRequest;
  return proto.TxRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TxRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TxRequest}
 */
proto.TxRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!proto.RequestType} */ (reader.readEnum());
      msg.setRequestType(value);
      break;
    case 2:
      var value = new types_pb.TxRequestDetailsType;
      reader.readMessage(value,types_pb.TxRequestDetailsType.deserializeBinaryFromReader);
      msg.setDetails(value);
      break;
    case 3:
      var value = new types_pb.TxRequestSerializedType;
      reader.readMessage(value,types_pb.TxRequestSerializedType.deserializeBinaryFromReader);
      msg.setSerialized(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TxRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TxRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TxRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!proto.RequestType} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeEnum(
      1,
      f
    );
  }
  f = message.getDetails();
  if (f != null) {
    writer.writeMessage(
      2,
      f,
      types_pb.TxRequestDetailsType.serializeBinaryToWriter
    );
  }
  f = message.getSerialized();
  if (f != null) {
    writer.writeMessage(
      3,
      f,
      types_pb.TxRequestSerializedType.serializeBinaryToWriter
    );
  }
};


/**
 * optional RequestType request_type = 1;
 * @return {!proto.RequestType}
 */
proto.TxRequest.prototype.getRequestType = function() {
  return /** @type {!proto.RequestType} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {!proto.RequestType} value */
proto.TxRequest.prototype.setRequestType = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.TxRequest.prototype.clearRequestType = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxRequest.prototype.hasRequestType = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional TxRequestDetailsType details = 2;
 * @return {?proto.TxRequestDetailsType}
 */
proto.TxRequest.prototype.getDetails = function() {
  return /** @type{?proto.TxRequestDetailsType} */ (
    jspb.Message.getWrapperField(this, types_pb.TxRequestDetailsType, 2));
};


/** @param {?proto.TxRequestDetailsType|undefined} value */
proto.TxRequest.prototype.setDetails = function(value) {
  jspb.Message.setWrapperField(this, 2, value);
};


proto.TxRequest.prototype.clearDetails = function() {
  this.setDetails(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxRequest.prototype.hasDetails = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional TxRequestSerializedType serialized = 3;
 * @return {?proto.TxRequestSerializedType}
 */
proto.TxRequest.prototype.getSerialized = function() {
  return /** @type{?proto.TxRequestSerializedType} */ (
    jspb.Message.getWrapperField(this, types_pb.TxRequestSerializedType, 3));
};


/** @param {?proto.TxRequestSerializedType|undefined} value */
proto.TxRequest.prototype.setSerialized = function(value) {
  jspb.Message.setWrapperField(this, 3, value);
};


proto.TxRequest.prototype.clearSerialized = function() {
  this.setSerialized(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxRequest.prototype.hasSerialized = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.TxAck = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.TxAck, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.TxAck.displayName = 'proto.TxAck';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.TxAck.prototype.toObject = function(opt_includeInstance) {
  return proto.TxAck.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.TxAck} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxAck.toObject = function(includeInstance, msg) {
  var f, obj = {
    tx: (f = msg.getTx()) && types_pb.TransactionType.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.TxAck}
 */
proto.TxAck.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.TxAck;
  return proto.TxAck.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.TxAck} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.TxAck}
 */
proto.TxAck.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new types_pb.TransactionType;
      reader.readMessage(value,types_pb.TransactionType.deserializeBinaryFromReader);
      msg.setTx(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.TxAck.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.TxAck.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.TxAck} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.TxAck.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTx();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      types_pb.TransactionType.serializeBinaryToWriter
    );
  }
};


/**
 * optional TransactionType tx = 1;
 * @return {?proto.TransactionType}
 */
proto.TxAck.prototype.getTx = function() {
  return /** @type{?proto.TransactionType} */ (
    jspb.Message.getWrapperField(this, types_pb.TransactionType, 1));
};


/** @param {?proto.TransactionType|undefined} value */
proto.TxAck.prototype.setTx = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.TxAck.prototype.clearTx = function() {
  this.setTx(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.TxAck.prototype.hasTx = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.RawTxAck = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.RawTxAck, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.RawTxAck.displayName = 'proto.RawTxAck';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.RawTxAck.prototype.toObject = function(opt_includeInstance) {
  return proto.RawTxAck.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.RawTxAck} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RawTxAck.toObject = function(includeInstance, msg) {
  var f, obj = {
    tx: (f = msg.getTx()) && types_pb.RawTransactionType.toObject(includeInstance, f)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.RawTxAck}
 */
proto.RawTxAck.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.RawTxAck;
  return proto.RawTxAck.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.RawTxAck} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.RawTxAck}
 */
proto.RawTxAck.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new types_pb.RawTransactionType;
      reader.readMessage(value,types_pb.RawTransactionType.deserializeBinaryFromReader);
      msg.setTx(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.RawTxAck.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.RawTxAck.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.RawTxAck} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.RawTxAck.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getTx();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      types_pb.RawTransactionType.serializeBinaryToWriter
    );
  }
};


/**
 * optional RawTransactionType tx = 1;
 * @return {?proto.RawTransactionType}
 */
proto.RawTxAck.prototype.getTx = function() {
  return /** @type{?proto.RawTransactionType} */ (
    jspb.Message.getWrapperField(this, types_pb.RawTransactionType, 1));
};


/** @param {?proto.RawTransactionType|undefined} value */
proto.RawTxAck.prototype.setTx = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.RawTxAck.prototype.clearTx = function() {
  this.setTx(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.RawTxAck.prototype.hasTx = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EthereumSignTx = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.EthereumSignTx.repeatedFields_, null);
};
goog.inherits(proto.EthereumSignTx, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.EthereumSignTx.displayName = 'proto.EthereumSignTx';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.EthereumSignTx.repeatedFields_ = [1,9];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EthereumSignTx.prototype.toObject = function(opt_includeInstance) {
  return proto.EthereumSignTx.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EthereumSignTx} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumSignTx.toObject = function(includeInstance, msg) {
  var f, obj = {
    addressNList: jspb.Message.getRepeatedField(msg, 1),
    nonce: msg.getNonce_asB64(),
    gasPrice: msg.getGasPrice_asB64(),
    gasLimit: msg.getGasLimit_asB64(),
    to: msg.getTo_asB64(),
    value: msg.getValue_asB64(),
    dataInitialChunk: msg.getDataInitialChunk_asB64(),
    dataLength: jspb.Message.getField(msg, 8),
    toAddressNList: jspb.Message.getRepeatedField(msg, 9),
    addressType: jspb.Message.getField(msg, 10),
    exchangeType: (f = msg.getExchangeType()) && types_pb.ExchangeType.toObject(includeInstance, f),
    chainId: jspb.Message.getField(msg, 12),
    tokenValue: msg.getTokenValue_asB64(),
    tokenTo: msg.getTokenTo_asB64(),
    tokenShortcut: jspb.Message.getField(msg, 102),
    txType: jspb.Message.getField(msg, 103)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EthereumSignTx}
 */
proto.EthereumSignTx.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EthereumSignTx;
  return proto.EthereumSignTx.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EthereumSignTx} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EthereumSignTx}
 */
proto.EthereumSignTx.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addAddressN(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setNonce(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setGasPrice(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setGasLimit(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTo(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setValue(value);
      break;
    case 7:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setDataInitialChunk(value);
      break;
    case 8:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDataLength(value);
      break;
    case 9:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addToAddressN(value);
      break;
    case 10:
      var value = /** @type {!proto.OutputAddressType} */ (reader.readEnum());
      msg.setAddressType(value);
      break;
    case 11:
      var value = new types_pb.ExchangeType;
      reader.readMessage(value,types_pb.ExchangeType.deserializeBinaryFromReader);
      msg.setExchangeType(value);
      break;
    case 12:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setChainId(value);
      break;
    case 100:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTokenValue(value);
      break;
    case 101:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setTokenTo(value);
      break;
    case 102:
      var value = /** @type {string} */ (reader.readString());
      msg.setTokenShortcut(value);
      break;
    case 103:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setTxType(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EthereumSignTx.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EthereumSignTx.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EthereumSignTx} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumSignTx.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeBytes(
      6,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeBytes(
      7,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeUint32(
      8,
      f
    );
  }
  f = message.getToAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      9,
      f
    );
  }
  f = /** @type {!proto.OutputAddressType} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeEnum(
      10,
      f
    );
  }
  f = message.getExchangeType();
  if (f != null) {
    writer.writeMessage(
      11,
      f,
      types_pb.ExchangeType.serializeBinaryToWriter
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 12));
  if (f != null) {
    writer.writeUint32(
      12,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 100));
  if (f != null) {
    writer.writeBytes(
      100,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 101));
  if (f != null) {
    writer.writeBytes(
      101,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 102));
  if (f != null) {
    writer.writeString(
      102,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 103));
  if (f != null) {
    writer.writeUint32(
      103,
      f
    );
  }
};


/**
 * repeated uint32 address_n = 1;
 * @return {!Array<number>}
 */
proto.EthereumSignTx.prototype.getAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array<number>} value */
proto.EthereumSignTx.prototype.setAddressNList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.EthereumSignTx.prototype.addAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.EthereumSignTx.prototype.clearAddressNList = function() {
  this.setAddressNList([]);
};


/**
 * optional bytes nonce = 2;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumSignTx.prototype.getNonce = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes nonce = 2;
 * This is a type-conversion wrapper around `getNonce()`
 * @return {string}
 */
proto.EthereumSignTx.prototype.getNonce_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getNonce()));
};


/**
 * optional bytes nonce = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getNonce()`
 * @return {!Uint8Array}
 */
proto.EthereumSignTx.prototype.getNonce_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getNonce()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumSignTx.prototype.setNonce = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.EthereumSignTx.prototype.clearNonce = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignTx.prototype.hasNonce = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes gas_price = 3;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumSignTx.prototype.getGasPrice = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes gas_price = 3;
 * This is a type-conversion wrapper around `getGasPrice()`
 * @return {string}
 */
proto.EthereumSignTx.prototype.getGasPrice_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getGasPrice()));
};


/**
 * optional bytes gas_price = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getGasPrice()`
 * @return {!Uint8Array}
 */
proto.EthereumSignTx.prototype.getGasPrice_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getGasPrice()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumSignTx.prototype.setGasPrice = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.EthereumSignTx.prototype.clearGasPrice = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignTx.prototype.hasGasPrice = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bytes gas_limit = 4;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumSignTx.prototype.getGasLimit = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes gas_limit = 4;
 * This is a type-conversion wrapper around `getGasLimit()`
 * @return {string}
 */
proto.EthereumSignTx.prototype.getGasLimit_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getGasLimit()));
};


/**
 * optional bytes gas_limit = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getGasLimit()`
 * @return {!Uint8Array}
 */
proto.EthereumSignTx.prototype.getGasLimit_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getGasLimit()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumSignTx.prototype.setGasLimit = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.EthereumSignTx.prototype.clearGasLimit = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignTx.prototype.hasGasLimit = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional bytes to = 5;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumSignTx.prototype.getTo = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes to = 5;
 * This is a type-conversion wrapper around `getTo()`
 * @return {string}
 */
proto.EthereumSignTx.prototype.getTo_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTo()));
};


/**
 * optional bytes to = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTo()`
 * @return {!Uint8Array}
 */
proto.EthereumSignTx.prototype.getTo_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTo()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumSignTx.prototype.setTo = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.EthereumSignTx.prototype.clearTo = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignTx.prototype.hasTo = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional bytes value = 6;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumSignTx.prototype.getValue = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * optional bytes value = 6;
 * This is a type-conversion wrapper around `getValue()`
 * @return {string}
 */
proto.EthereumSignTx.prototype.getValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getValue()));
};


/**
 * optional bytes value = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getValue()`
 * @return {!Uint8Array}
 */
proto.EthereumSignTx.prototype.getValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getValue()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumSignTx.prototype.setValue = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.EthereumSignTx.prototype.clearValue = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignTx.prototype.hasValue = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional bytes data_initial_chunk = 7;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumSignTx.prototype.getDataInitialChunk = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/**
 * optional bytes data_initial_chunk = 7;
 * This is a type-conversion wrapper around `getDataInitialChunk()`
 * @return {string}
 */
proto.EthereumSignTx.prototype.getDataInitialChunk_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getDataInitialChunk()));
};


/**
 * optional bytes data_initial_chunk = 7;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getDataInitialChunk()`
 * @return {!Uint8Array}
 */
proto.EthereumSignTx.prototype.getDataInitialChunk_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getDataInitialChunk()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumSignTx.prototype.setDataInitialChunk = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.EthereumSignTx.prototype.clearDataInitialChunk = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignTx.prototype.hasDataInitialChunk = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional uint32 data_length = 8;
 * @return {number}
 */
proto.EthereumSignTx.prototype.getDataLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 8, 0));
};


/** @param {number} value */
proto.EthereumSignTx.prototype.setDataLength = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.EthereumSignTx.prototype.clearDataLength = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignTx.prototype.hasDataLength = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * repeated uint32 to_address_n = 9;
 * @return {!Array<number>}
 */
proto.EthereumSignTx.prototype.getToAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 9));
};


/** @param {!Array<number>} value */
proto.EthereumSignTx.prototype.setToAddressNList = function(value) {
  jspb.Message.setField(this, 9, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.EthereumSignTx.prototype.addToAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 9, value, opt_index);
};


proto.EthereumSignTx.prototype.clearToAddressNList = function() {
  this.setToAddressNList([]);
};


/**
 * optional OutputAddressType address_type = 10;
 * @return {!proto.OutputAddressType}
 */
proto.EthereumSignTx.prototype.getAddressType = function() {
  return /** @type {!proto.OutputAddressType} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {!proto.OutputAddressType} value */
proto.EthereumSignTx.prototype.setAddressType = function(value) {
  jspb.Message.setField(this, 10, value);
};


proto.EthereumSignTx.prototype.clearAddressType = function() {
  jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignTx.prototype.hasAddressType = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional ExchangeType exchange_type = 11;
 * @return {?proto.ExchangeType}
 */
proto.EthereumSignTx.prototype.getExchangeType = function() {
  return /** @type{?proto.ExchangeType} */ (
    jspb.Message.getWrapperField(this, types_pb.ExchangeType, 11));
};


/** @param {?proto.ExchangeType|undefined} value */
proto.EthereumSignTx.prototype.setExchangeType = function(value) {
  jspb.Message.setWrapperField(this, 11, value);
};


proto.EthereumSignTx.prototype.clearExchangeType = function() {
  this.setExchangeType(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignTx.prototype.hasExchangeType = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * optional uint32 chain_id = 12;
 * @return {number}
 */
proto.EthereumSignTx.prototype.getChainId = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 12, 0));
};


/** @param {number} value */
proto.EthereumSignTx.prototype.setChainId = function(value) {
  jspb.Message.setField(this, 12, value);
};


proto.EthereumSignTx.prototype.clearChainId = function() {
  jspb.Message.setField(this, 12, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignTx.prototype.hasChainId = function() {
  return jspb.Message.getField(this, 12) != null;
};


/**
 * optional bytes token_value = 100;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumSignTx.prototype.getTokenValue = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 100, ""));
};


/**
 * optional bytes token_value = 100;
 * This is a type-conversion wrapper around `getTokenValue()`
 * @return {string}
 */
proto.EthereumSignTx.prototype.getTokenValue_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTokenValue()));
};


/**
 * optional bytes token_value = 100;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTokenValue()`
 * @return {!Uint8Array}
 */
proto.EthereumSignTx.prototype.getTokenValue_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTokenValue()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumSignTx.prototype.setTokenValue = function(value) {
  jspb.Message.setField(this, 100, value);
};


proto.EthereumSignTx.prototype.clearTokenValue = function() {
  jspb.Message.setField(this, 100, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignTx.prototype.hasTokenValue = function() {
  return jspb.Message.getField(this, 100) != null;
};


/**
 * optional bytes token_to = 101;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumSignTx.prototype.getTokenTo = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 101, ""));
};


/**
 * optional bytes token_to = 101;
 * This is a type-conversion wrapper around `getTokenTo()`
 * @return {string}
 */
proto.EthereumSignTx.prototype.getTokenTo_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getTokenTo()));
};


/**
 * optional bytes token_to = 101;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getTokenTo()`
 * @return {!Uint8Array}
 */
proto.EthereumSignTx.prototype.getTokenTo_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getTokenTo()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumSignTx.prototype.setTokenTo = function(value) {
  jspb.Message.setField(this, 101, value);
};


proto.EthereumSignTx.prototype.clearTokenTo = function() {
  jspb.Message.setField(this, 101, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignTx.prototype.hasTokenTo = function() {
  return jspb.Message.getField(this, 101) != null;
};


/**
 * optional string token_shortcut = 102;
 * @return {string}
 */
proto.EthereumSignTx.prototype.getTokenShortcut = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 102, ""));
};


/** @param {string} value */
proto.EthereumSignTx.prototype.setTokenShortcut = function(value) {
  jspb.Message.setField(this, 102, value);
};


proto.EthereumSignTx.prototype.clearTokenShortcut = function() {
  jspb.Message.setField(this, 102, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignTx.prototype.hasTokenShortcut = function() {
  return jspb.Message.getField(this, 102) != null;
};


/**
 * optional uint32 tx_type = 103;
 * @return {number}
 */
proto.EthereumSignTx.prototype.getTxType = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 103, 0));
};


/** @param {number} value */
proto.EthereumSignTx.prototype.setTxType = function(value) {
  jspb.Message.setField(this, 103, value);
};


proto.EthereumSignTx.prototype.clearTxType = function() {
  jspb.Message.setField(this, 103, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignTx.prototype.hasTxType = function() {
  return jspb.Message.getField(this, 103) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EthereumTxRequest = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.EthereumTxRequest, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.EthereumTxRequest.displayName = 'proto.EthereumTxRequest';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EthereumTxRequest.prototype.toObject = function(opt_includeInstance) {
  return proto.EthereumTxRequest.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EthereumTxRequest} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumTxRequest.toObject = function(includeInstance, msg) {
  var f, obj = {
    dataLength: jspb.Message.getField(msg, 1),
    signatureV: jspb.Message.getField(msg, 2),
    signatureR: msg.getSignatureR_asB64(),
    signatureS: msg.getSignatureS_asB64(),
    hash: msg.getHash_asB64(),
    signatureDer: msg.getSignatureDer_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EthereumTxRequest}
 */
proto.EthereumTxRequest.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EthereumTxRequest;
  return proto.EthereumTxRequest.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EthereumTxRequest} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EthereumTxRequest}
 */
proto.EthereumTxRequest.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setDataLength(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setSignatureV(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignatureR(value);
      break;
    case 4:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignatureS(value);
      break;
    case 5:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setHash(value);
      break;
    case 6:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignatureDer(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EthereumTxRequest.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EthereumTxRequest.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EthereumTxRequest} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumTxRequest.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBytes(
      3,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeBytes(
      4,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 5));
  if (f != null) {
    writer.writeBytes(
      5,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeBytes(
      6,
      f
    );
  }
};


/**
 * optional uint32 data_length = 1;
 * @return {number}
 */
proto.EthereumTxRequest.prototype.getDataLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.EthereumTxRequest.prototype.setDataLength = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.EthereumTxRequest.prototype.clearDataLength = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumTxRequest.prototype.hasDataLength = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 signature_v = 2;
 * @return {number}
 */
proto.EthereumTxRequest.prototype.getSignatureV = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.EthereumTxRequest.prototype.setSignatureV = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.EthereumTxRequest.prototype.clearSignatureV = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumTxRequest.prototype.hasSignatureV = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes signature_r = 3;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumTxRequest.prototype.getSignatureR = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes signature_r = 3;
 * This is a type-conversion wrapper around `getSignatureR()`
 * @return {string}
 */
proto.EthereumTxRequest.prototype.getSignatureR_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignatureR()));
};


/**
 * optional bytes signature_r = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignatureR()`
 * @return {!Uint8Array}
 */
proto.EthereumTxRequest.prototype.getSignatureR_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignatureR()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumTxRequest.prototype.setSignatureR = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.EthereumTxRequest.prototype.clearSignatureR = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumTxRequest.prototype.hasSignatureR = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional bytes signature_s = 4;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumTxRequest.prototype.getSignatureS = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/**
 * optional bytes signature_s = 4;
 * This is a type-conversion wrapper around `getSignatureS()`
 * @return {string}
 */
proto.EthereumTxRequest.prototype.getSignatureS_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignatureS()));
};


/**
 * optional bytes signature_s = 4;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignatureS()`
 * @return {!Uint8Array}
 */
proto.EthereumTxRequest.prototype.getSignatureS_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignatureS()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumTxRequest.prototype.setSignatureS = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.EthereumTxRequest.prototype.clearSignatureS = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumTxRequest.prototype.hasSignatureS = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional bytes hash = 5;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumTxRequest.prototype.getHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 5, ""));
};


/**
 * optional bytes hash = 5;
 * This is a type-conversion wrapper around `getHash()`
 * @return {string}
 */
proto.EthereumTxRequest.prototype.getHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getHash()));
};


/**
 * optional bytes hash = 5;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getHash()`
 * @return {!Uint8Array}
 */
proto.EthereumTxRequest.prototype.getHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumTxRequest.prototype.setHash = function(value) {
  jspb.Message.setField(this, 5, value);
};


proto.EthereumTxRequest.prototype.clearHash = function() {
  jspb.Message.setField(this, 5, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumTxRequest.prototype.hasHash = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional bytes signature_der = 6;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumTxRequest.prototype.getSignatureDer = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 6, ""));
};


/**
 * optional bytes signature_der = 6;
 * This is a type-conversion wrapper around `getSignatureDer()`
 * @return {string}
 */
proto.EthereumTxRequest.prototype.getSignatureDer_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignatureDer()));
};


/**
 * optional bytes signature_der = 6;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignatureDer()`
 * @return {!Uint8Array}
 */
proto.EthereumTxRequest.prototype.getSignatureDer_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignatureDer()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumTxRequest.prototype.setSignatureDer = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.EthereumTxRequest.prototype.clearSignatureDer = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumTxRequest.prototype.hasSignatureDer = function() {
  return jspb.Message.getField(this, 6) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EthereumTxAck = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.EthereumTxAck, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.EthereumTxAck.displayName = 'proto.EthereumTxAck';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EthereumTxAck.prototype.toObject = function(opt_includeInstance) {
  return proto.EthereumTxAck.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EthereumTxAck} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumTxAck.toObject = function(includeInstance, msg) {
  var f, obj = {
    dataChunk: msg.getDataChunk_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EthereumTxAck}
 */
proto.EthereumTxAck.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EthereumTxAck;
  return proto.EthereumTxAck.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EthereumTxAck} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EthereumTxAck}
 */
proto.EthereumTxAck.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setDataChunk(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EthereumTxAck.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EthereumTxAck.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EthereumTxAck} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumTxAck.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes data_chunk = 1;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumTxAck.prototype.getDataChunk = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes data_chunk = 1;
 * This is a type-conversion wrapper around `getDataChunk()`
 * @return {string}
 */
proto.EthereumTxAck.prototype.getDataChunk_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getDataChunk()));
};


/**
 * optional bytes data_chunk = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getDataChunk()`
 * @return {!Uint8Array}
 */
proto.EthereumTxAck.prototype.getDataChunk_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getDataChunk()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumTxAck.prototype.setDataChunk = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.EthereumTxAck.prototype.clearDataChunk = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumTxAck.prototype.hasDataChunk = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EthereumSignMessage = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.EthereumSignMessage.repeatedFields_, null);
};
goog.inherits(proto.EthereumSignMessage, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.EthereumSignMessage.displayName = 'proto.EthereumSignMessage';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.EthereumSignMessage.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EthereumSignMessage.prototype.toObject = function(opt_includeInstance) {
  return proto.EthereumSignMessage.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EthereumSignMessage} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumSignMessage.toObject = function(includeInstance, msg) {
  var f, obj = {
    addressNList: jspb.Message.getRepeatedField(msg, 1),
    message: msg.getMessage_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EthereumSignMessage}
 */
proto.EthereumSignMessage.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EthereumSignMessage;
  return proto.EthereumSignMessage.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EthereumSignMessage} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EthereumSignMessage}
 */
proto.EthereumSignMessage.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.addAddressN(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EthereumSignMessage.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EthereumSignMessage.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EthereumSignMessage} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumSignMessage.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getAddressNList();
  if (f.length > 0) {
    writer.writeRepeatedUint32(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * repeated uint32 address_n = 1;
 * @return {!Array<number>}
 */
proto.EthereumSignMessage.prototype.getAddressNList = function() {
  return /** @type {!Array<number>} */ (jspb.Message.getRepeatedField(this, 1));
};


/** @param {!Array<number>} value */
proto.EthereumSignMessage.prototype.setAddressNList = function(value) {
  jspb.Message.setField(this, 1, value || []);
};


/**
 * @param {!number} value
 * @param {number=} opt_index
 */
proto.EthereumSignMessage.prototype.addAddressN = function(value, opt_index) {
  jspb.Message.addToRepeatedField(this, 1, value, opt_index);
};


proto.EthereumSignMessage.prototype.clearAddressNList = function() {
  this.setAddressNList([]);
};


/**
 * required bytes message = 2;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumSignMessage.prototype.getMessage = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * required bytes message = 2;
 * This is a type-conversion wrapper around `getMessage()`
 * @return {string}
 */
proto.EthereumSignMessage.prototype.getMessage_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMessage()));
};


/**
 * required bytes message = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMessage()`
 * @return {!Uint8Array}
 */
proto.EthereumSignMessage.prototype.getMessage_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMessage()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumSignMessage.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.EthereumSignMessage.prototype.clearMessage = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumSignMessage.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EthereumVerifyMessage = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.EthereumVerifyMessage, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.EthereumVerifyMessage.displayName = 'proto.EthereumVerifyMessage';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EthereumVerifyMessage.prototype.toObject = function(opt_includeInstance) {
  return proto.EthereumVerifyMessage.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EthereumVerifyMessage} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumVerifyMessage.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: msg.getAddress_asB64(),
    signature: msg.getSignature_asB64(),
    message: msg.getMessage_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EthereumVerifyMessage}
 */
proto.EthereumVerifyMessage.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EthereumVerifyMessage;
  return proto.EthereumVerifyMessage.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EthereumVerifyMessage} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EthereumVerifyMessage}
 */
proto.EthereumVerifyMessage.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setMessage(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EthereumVerifyMessage.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EthereumVerifyMessage.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EthereumVerifyMessage} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumVerifyMessage.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional bytes address = 1;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumVerifyMessage.prototype.getAddress = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes address = 1;
 * This is a type-conversion wrapper around `getAddress()`
 * @return {string}
 */
proto.EthereumVerifyMessage.prototype.getAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAddress()));
};


/**
 * optional bytes address = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAddress()`
 * @return {!Uint8Array}
 */
proto.EthereumVerifyMessage.prototype.getAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAddress()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumVerifyMessage.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.EthereumVerifyMessage.prototype.clearAddress = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumVerifyMessage.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes signature = 2;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumVerifyMessage.prototype.getSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes signature = 2;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.EthereumVerifyMessage.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.EthereumVerifyMessage.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumVerifyMessage.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.EthereumVerifyMessage.prototype.clearSignature = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumVerifyMessage.prototype.hasSignature = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes message = 3;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumVerifyMessage.prototype.getMessage = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes message = 3;
 * This is a type-conversion wrapper around `getMessage()`
 * @return {string}
 */
proto.EthereumVerifyMessage.prototype.getMessage_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getMessage()));
};


/**
 * optional bytes message = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getMessage()`
 * @return {!Uint8Array}
 */
proto.EthereumVerifyMessage.prototype.getMessage_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getMessage()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumVerifyMessage.prototype.setMessage = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.EthereumVerifyMessage.prototype.clearMessage = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumVerifyMessage.prototype.hasMessage = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.EthereumMessageSignature = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.EthereumMessageSignature, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.EthereumMessageSignature.displayName = 'proto.EthereumMessageSignature';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.EthereumMessageSignature.prototype.toObject = function(opt_includeInstance) {
  return proto.EthereumMessageSignature.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.EthereumMessageSignature} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumMessageSignature.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: msg.getAddress_asB64(),
    signature: msg.getSignature_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.EthereumMessageSignature}
 */
proto.EthereumMessageSignature.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.EthereumMessageSignature;
  return proto.EthereumMessageSignature.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.EthereumMessageSignature} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.EthereumMessageSignature}
 */
proto.EthereumMessageSignature.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.EthereumMessageSignature.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.EthereumMessageSignature.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.EthereumMessageSignature} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.EthereumMessageSignature.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * optional bytes address = 1;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumMessageSignature.prototype.getAddress = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes address = 1;
 * This is a type-conversion wrapper around `getAddress()`
 * @return {string}
 */
proto.EthereumMessageSignature.prototype.getAddress_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getAddress()));
};


/**
 * optional bytes address = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getAddress()`
 * @return {!Uint8Array}
 */
proto.EthereumMessageSignature.prototype.getAddress_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getAddress()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumMessageSignature.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.EthereumMessageSignature.prototype.clearAddress = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumMessageSignature.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes signature = 2;
 * @return {!(string|Uint8Array)}
 */
proto.EthereumMessageSignature.prototype.getSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes signature = 2;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.EthereumMessageSignature.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.EthereumMessageSignature.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value */
proto.EthereumMessageSignature.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.EthereumMessageSignature.prototype.clearSignature = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.EthereumMessageSignature.prototype.hasSignature = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SignIdentity = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SignIdentity, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SignIdentity.displayName = 'proto.SignIdentity';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SignIdentity.prototype.toObject = function(opt_includeInstance) {
  return proto.SignIdentity.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SignIdentity} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SignIdentity.toObject = function(includeInstance, msg) {
  var f, obj = {
    identity: (f = msg.getIdentity()) && types_pb.IdentityType.toObject(includeInstance, f),
    challengeHidden: msg.getChallengeHidden_asB64(),
    challengeVisual: jspb.Message.getField(msg, 3),
    ecdsaCurveName: jspb.Message.getField(msg, 4)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SignIdentity}
 */
proto.SignIdentity.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SignIdentity;
  return proto.SignIdentity.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SignIdentity} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SignIdentity}
 */
proto.SignIdentity.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new types_pb.IdentityType;
      reader.readMessage(value,types_pb.IdentityType.deserializeBinaryFromReader);
      msg.setIdentity(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setChallengeHidden(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setChallengeVisual(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setEcdsaCurveName(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SignIdentity.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SignIdentity.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SignIdentity} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SignIdentity.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getIdentity();
  if (f != null) {
    writer.writeMessage(
      1,
      f,
      types_pb.IdentityType.serializeBinaryToWriter
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeString(
      4,
      f
    );
  }
};


/**
 * optional IdentityType identity = 1;
 * @return {?proto.IdentityType}
 */
proto.SignIdentity.prototype.getIdentity = function() {
  return /** @type{?proto.IdentityType} */ (
    jspb.Message.getWrapperField(this, types_pb.IdentityType, 1));
};


/** @param {?proto.IdentityType|undefined} value */
proto.SignIdentity.prototype.setIdentity = function(value) {
  jspb.Message.setWrapperField(this, 1, value);
};


proto.SignIdentity.prototype.clearIdentity = function() {
  this.setIdentity(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignIdentity.prototype.hasIdentity = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes challenge_hidden = 2;
 * @return {!(string|Uint8Array)}
 */
proto.SignIdentity.prototype.getChallengeHidden = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes challenge_hidden = 2;
 * This is a type-conversion wrapper around `getChallengeHidden()`
 * @return {string}
 */
proto.SignIdentity.prototype.getChallengeHidden_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getChallengeHidden()));
};


/**
 * optional bytes challenge_hidden = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getChallengeHidden()`
 * @return {!Uint8Array}
 */
proto.SignIdentity.prototype.getChallengeHidden_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getChallengeHidden()));
};


/** @param {!(string|Uint8Array)} value */
proto.SignIdentity.prototype.setChallengeHidden = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SignIdentity.prototype.clearChallengeHidden = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignIdentity.prototype.hasChallengeHidden = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional string challenge_visual = 3;
 * @return {string}
 */
proto.SignIdentity.prototype.getChallengeVisual = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.SignIdentity.prototype.setChallengeVisual = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SignIdentity.prototype.clearChallengeVisual = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignIdentity.prototype.hasChallengeVisual = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional string ecdsa_curve_name = 4;
 * @return {string}
 */
proto.SignIdentity.prototype.getEcdsaCurveName = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.SignIdentity.prototype.setEcdsaCurveName = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.SignIdentity.prototype.clearEcdsaCurveName = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignIdentity.prototype.hasEcdsaCurveName = function() {
  return jspb.Message.getField(this, 4) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SignedIdentity = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SignedIdentity, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SignedIdentity.displayName = 'proto.SignedIdentity';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SignedIdentity.prototype.toObject = function(opt_includeInstance) {
  return proto.SignedIdentity.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SignedIdentity} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SignedIdentity.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getField(msg, 1),
    publicKey: msg.getPublicKey_asB64(),
    signature: msg.getSignature_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SignedIdentity}
 */
proto.SignedIdentity.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SignedIdentity;
  return proto.SignedIdentity.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SignedIdentity} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SignedIdentity}
 */
proto.SignedIdentity.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {string} */ (reader.readString());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPublicKey(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setSignature(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SignedIdentity.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SignedIdentity.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SignedIdentity} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SignedIdentity.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {string} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeString(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional string address = 1;
 * @return {string}
 */
proto.SignedIdentity.prototype.getAddress = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/** @param {string} value */
proto.SignedIdentity.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.SignedIdentity.prototype.clearAddress = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignedIdentity.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes public_key = 2;
 * @return {!(string|Uint8Array)}
 */
proto.SignedIdentity.prototype.getPublicKey = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes public_key = 2;
 * This is a type-conversion wrapper around `getPublicKey()`
 * @return {string}
 */
proto.SignedIdentity.prototype.getPublicKey_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPublicKey()));
};


/**
 * optional bytes public_key = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPublicKey()`
 * @return {!Uint8Array}
 */
proto.SignedIdentity.prototype.getPublicKey_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPublicKey()));
};


/** @param {!(string|Uint8Array)} value */
proto.SignedIdentity.prototype.setPublicKey = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.SignedIdentity.prototype.clearPublicKey = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignedIdentity.prototype.hasPublicKey = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes signature = 3;
 * @return {!(string|Uint8Array)}
 */
proto.SignedIdentity.prototype.getSignature = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes signature = 3;
 * This is a type-conversion wrapper around `getSignature()`
 * @return {string}
 */
proto.SignedIdentity.prototype.getSignature_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getSignature()));
};


/**
 * optional bytes signature = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getSignature()`
 * @return {!Uint8Array}
 */
proto.SignedIdentity.prototype.getSignature_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getSignature()));
};


/** @param {!(string|Uint8Array)} value */
proto.SignedIdentity.prototype.setSignature = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.SignedIdentity.prototype.clearSignature = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.SignedIdentity.prototype.hasSignature = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.ApplyPolicies = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, proto.ApplyPolicies.repeatedFields_, null);
};
goog.inherits(proto.ApplyPolicies, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.ApplyPolicies.displayName = 'proto.ApplyPolicies';
}
/**
 * List of repeated fields within this message type.
 * @private {!Array<number>}
 * @const
 */
proto.ApplyPolicies.repeatedFields_ = [1];



if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.ApplyPolicies.prototype.toObject = function(opt_includeInstance) {
  return proto.ApplyPolicies.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.ApplyPolicies} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ApplyPolicies.toObject = function(includeInstance, msg) {
  var f, obj = {
    policyList: jspb.Message.toObjectList(msg.getPolicyList(),
    types_pb.PolicyType.toObject, includeInstance)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.ApplyPolicies}
 */
proto.ApplyPolicies.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.ApplyPolicies;
  return proto.ApplyPolicies.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.ApplyPolicies} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.ApplyPolicies}
 */
proto.ApplyPolicies.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = new types_pb.PolicyType;
      reader.readMessage(value,types_pb.PolicyType.deserializeBinaryFromReader);
      msg.addPolicy(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.ApplyPolicies.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.ApplyPolicies.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.ApplyPolicies} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.ApplyPolicies.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = message.getPolicyList();
  if (f.length > 0) {
    writer.writeRepeatedMessage(
      1,
      f,
      types_pb.PolicyType.serializeBinaryToWriter
    );
  }
};


/**
 * repeated PolicyType policy = 1;
 * @return {!Array<!proto.PolicyType>}
 */
proto.ApplyPolicies.prototype.getPolicyList = function() {
  return /** @type{!Array<!proto.PolicyType>} */ (
    jspb.Message.getRepeatedWrapperField(this, types_pb.PolicyType, 1));
};


/** @param {!Array<!proto.PolicyType>} value */
proto.ApplyPolicies.prototype.setPolicyList = function(value) {
  jspb.Message.setRepeatedWrapperField(this, 1, value);
};


/**
 * @param {!proto.PolicyType=} opt_value
 * @param {number=} opt_index
 * @return {!proto.PolicyType}
 */
proto.ApplyPolicies.prototype.addPolicy = function(opt_value, opt_index) {
  return jspb.Message.addToRepeatedWrapperField(this, 1, opt_value, proto.PolicyType, opt_index);
};


proto.ApplyPolicies.prototype.clearPolicyList = function() {
  this.setPolicyList([]);
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.FlashHash = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.FlashHash, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.FlashHash.displayName = 'proto.FlashHash';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.FlashHash.prototype.toObject = function(opt_includeInstance) {
  return proto.FlashHash.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.FlashHash} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.FlashHash.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getField(msg, 1),
    length: jspb.Message.getField(msg, 2),
    challenge: msg.getChallenge_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.FlashHash}
 */
proto.FlashHash.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.FlashHash;
  return proto.FlashHash.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.FlashHash} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.FlashHash}
 */
proto.FlashHash.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLength(value);
      break;
    case 3:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setChallenge(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.FlashHash.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.FlashHash.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.FlashHash} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.FlashHash.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBytes(
      3,
      f
    );
  }
};


/**
 * optional uint32 address = 1;
 * @return {number}
 */
proto.FlashHash.prototype.getAddress = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.FlashHash.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.FlashHash.prototype.clearAddress = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.FlashHash.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 length = 2;
 * @return {number}
 */
proto.FlashHash.prototype.getLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.FlashHash.prototype.setLength = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.FlashHash.prototype.clearLength = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.FlashHash.prototype.hasLength = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bytes challenge = 3;
 * @return {!(string|Uint8Array)}
 */
proto.FlashHash.prototype.getChallenge = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/**
 * optional bytes challenge = 3;
 * This is a type-conversion wrapper around `getChallenge()`
 * @return {string}
 */
proto.FlashHash.prototype.getChallenge_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getChallenge()));
};


/**
 * optional bytes challenge = 3;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getChallenge()`
 * @return {!Uint8Array}
 */
proto.FlashHash.prototype.getChallenge_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getChallenge()));
};


/** @param {!(string|Uint8Array)} value */
proto.FlashHash.prototype.setChallenge = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.FlashHash.prototype.clearChallenge = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.FlashHash.prototype.hasChallenge = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.FlashWrite = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.FlashWrite, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.FlashWrite.displayName = 'proto.FlashWrite';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.FlashWrite.prototype.toObject = function(opt_includeInstance) {
  return proto.FlashWrite.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.FlashWrite} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.FlashWrite.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getField(msg, 1),
    data: msg.getData_asB64(),
    erase: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.FlashWrite}
 */
proto.FlashWrite.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.FlashWrite;
  return proto.FlashWrite.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.FlashWrite} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.FlashWrite}
 */
proto.FlashWrite.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setData(value);
      break;
    case 3:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setErase(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.FlashWrite.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.FlashWrite.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.FlashWrite} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.FlashWrite.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeBool(
      3,
      f
    );
  }
};


/**
 * optional uint32 address = 1;
 * @return {number}
 */
proto.FlashWrite.prototype.getAddress = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.FlashWrite.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.FlashWrite.prototype.clearAddress = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.FlashWrite.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional bytes data = 2;
 * @return {!(string|Uint8Array)}
 */
proto.FlashWrite.prototype.getData = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * optional bytes data = 2;
 * This is a type-conversion wrapper around `getData()`
 * @return {string}
 */
proto.FlashWrite.prototype.getData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getData()));
};


/**
 * optional bytes data = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getData()`
 * @return {!Uint8Array}
 */
proto.FlashWrite.prototype.getData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getData()));
};


/** @param {!(string|Uint8Array)} value */
proto.FlashWrite.prototype.setData = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.FlashWrite.prototype.clearData = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.FlashWrite.prototype.hasData = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional bool erase = 3;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.FlashWrite.prototype.getErase = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 3, false));
};


/** @param {boolean} value */
proto.FlashWrite.prototype.setErase = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.FlashWrite.prototype.clearErase = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.FlashWrite.prototype.hasErase = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.FlashHashResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.FlashHashResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.FlashHashResponse.displayName = 'proto.FlashHashResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.FlashHashResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.FlashHashResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.FlashHashResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.FlashHashResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    data: msg.getData_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.FlashHashResponse}
 */
proto.FlashHashResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.FlashHashResponse;
  return proto.FlashHashResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.FlashHashResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.FlashHashResponse}
 */
proto.FlashHashResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.FlashHashResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.FlashHashResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.FlashHashResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.FlashHashResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes data = 1;
 * @return {!(string|Uint8Array)}
 */
proto.FlashHashResponse.prototype.getData = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes data = 1;
 * This is a type-conversion wrapper around `getData()`
 * @return {string}
 */
proto.FlashHashResponse.prototype.getData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getData()));
};


/**
 * optional bytes data = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getData()`
 * @return {!Uint8Array}
 */
proto.FlashHashResponse.prototype.getData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getData()));
};


/** @param {!(string|Uint8Array)} value */
proto.FlashHashResponse.prototype.setData = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.FlashHashResponse.prototype.clearData = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.FlashHashResponse.prototype.hasData = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.DebugLinkFlashDump = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.DebugLinkFlashDump, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.DebugLinkFlashDump.displayName = 'proto.DebugLinkFlashDump';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.DebugLinkFlashDump.prototype.toObject = function(opt_includeInstance) {
  return proto.DebugLinkFlashDump.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.DebugLinkFlashDump} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkFlashDump.toObject = function(includeInstance, msg) {
  var f, obj = {
    address: jspb.Message.getField(msg, 1),
    length: jspb.Message.getField(msg, 2)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.DebugLinkFlashDump}
 */
proto.DebugLinkFlashDump.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.DebugLinkFlashDump;
  return proto.DebugLinkFlashDump.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.DebugLinkFlashDump} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.DebugLinkFlashDump}
 */
proto.DebugLinkFlashDump.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setAddress(value);
      break;
    case 2:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLength(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.DebugLinkFlashDump.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.DebugLinkFlashDump.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.DebugLinkFlashDump} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkFlashDump.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeUint32(
      2,
      f
    );
  }
};


/**
 * optional uint32 address = 1;
 * @return {number}
 */
proto.DebugLinkFlashDump.prototype.getAddress = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.DebugLinkFlashDump.prototype.setAddress = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.DebugLinkFlashDump.prototype.clearAddress = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkFlashDump.prototype.hasAddress = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional uint32 length = 2;
 * @return {number}
 */
proto.DebugLinkFlashDump.prototype.getLength = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 2, 0));
};


/** @param {number} value */
proto.DebugLinkFlashDump.prototype.setLength = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.DebugLinkFlashDump.prototype.clearLength = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkFlashDump.prototype.hasLength = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.DebugLinkFlashDumpResponse = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.DebugLinkFlashDumpResponse, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.DebugLinkFlashDumpResponse.displayName = 'proto.DebugLinkFlashDumpResponse';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.DebugLinkFlashDumpResponse.prototype.toObject = function(opt_includeInstance) {
  return proto.DebugLinkFlashDumpResponse.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.DebugLinkFlashDumpResponse} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkFlashDumpResponse.toObject = function(includeInstance, msg) {
  var f, obj = {
    data: msg.getData_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.DebugLinkFlashDumpResponse}
 */
proto.DebugLinkFlashDumpResponse.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.DebugLinkFlashDumpResponse;
  return proto.DebugLinkFlashDumpResponse.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.DebugLinkFlashDumpResponse} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.DebugLinkFlashDumpResponse}
 */
proto.DebugLinkFlashDumpResponse.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setData(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.DebugLinkFlashDumpResponse.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.DebugLinkFlashDumpResponse.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.DebugLinkFlashDumpResponse} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkFlashDumpResponse.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
};


/**
 * optional bytes data = 1;
 * @return {!(string|Uint8Array)}
 */
proto.DebugLinkFlashDumpResponse.prototype.getData = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes data = 1;
 * This is a type-conversion wrapper around `getData()`
 * @return {string}
 */
proto.DebugLinkFlashDumpResponse.prototype.getData_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getData()));
};


/**
 * optional bytes data = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getData()`
 * @return {!Uint8Array}
 */
proto.DebugLinkFlashDumpResponse.prototype.getData_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getData()));
};


/** @param {!(string|Uint8Array)} value */
proto.DebugLinkFlashDumpResponse.prototype.setData = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.DebugLinkFlashDumpResponse.prototype.clearData = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkFlashDumpResponse.prototype.hasData = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.SoftReset = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.SoftReset, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.SoftReset.displayName = 'proto.SoftReset';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.SoftReset.prototype.toObject = function(opt_includeInstance) {
  return proto.SoftReset.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.SoftReset} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SoftReset.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.SoftReset}
 */
proto.SoftReset.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.SoftReset;
  return proto.SoftReset.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.SoftReset} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.SoftReset}
 */
proto.SoftReset.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.SoftReset.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.SoftReset.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.SoftReset} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.SoftReset.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.FirmwareErase = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.FirmwareErase, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.FirmwareErase.displayName = 'proto.FirmwareErase';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.FirmwareErase.prototype.toObject = function(opt_includeInstance) {
  return proto.FirmwareErase.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.FirmwareErase} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.FirmwareErase.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.FirmwareErase}
 */
proto.FirmwareErase.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.FirmwareErase;
  return proto.FirmwareErase.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.FirmwareErase} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.FirmwareErase}
 */
proto.FirmwareErase.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.FirmwareErase.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.FirmwareErase.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.FirmwareErase} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.FirmwareErase.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.FirmwareUpload = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.FirmwareUpload, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.FirmwareUpload.displayName = 'proto.FirmwareUpload';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.FirmwareUpload.prototype.toObject = function(opt_includeInstance) {
  return proto.FirmwareUpload.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.FirmwareUpload} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.FirmwareUpload.toObject = function(includeInstance, msg) {
  var f, obj = {
    payloadHash: msg.getPayloadHash_asB64(),
    payload: msg.getPayload_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.FirmwareUpload}
 */
proto.FirmwareUpload.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.FirmwareUpload;
  return proto.FirmwareUpload.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.FirmwareUpload} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.FirmwareUpload}
 */
proto.FirmwareUpload.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPayloadHash(value);
      break;
    case 2:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setPayload(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.FirmwareUpload.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.FirmwareUpload.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.FirmwareUpload} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.FirmwareUpload.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeBytes(
      2,
      f
    );
  }
};


/**
 * required bytes payload_hash = 1;
 * @return {!(string|Uint8Array)}
 */
proto.FirmwareUpload.prototype.getPayloadHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * required bytes payload_hash = 1;
 * This is a type-conversion wrapper around `getPayloadHash()`
 * @return {string}
 */
proto.FirmwareUpload.prototype.getPayloadHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPayloadHash()));
};


/**
 * required bytes payload_hash = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPayloadHash()`
 * @return {!Uint8Array}
 */
proto.FirmwareUpload.prototype.getPayloadHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPayloadHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.FirmwareUpload.prototype.setPayloadHash = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.FirmwareUpload.prototype.clearPayloadHash = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.FirmwareUpload.prototype.hasPayloadHash = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * required bytes payload = 2;
 * @return {!(string|Uint8Array)}
 */
proto.FirmwareUpload.prototype.getPayload = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/**
 * required bytes payload = 2;
 * This is a type-conversion wrapper around `getPayload()`
 * @return {string}
 */
proto.FirmwareUpload.prototype.getPayload_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getPayload()));
};


/**
 * required bytes payload = 2;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getPayload()`
 * @return {!Uint8Array}
 */
proto.FirmwareUpload.prototype.getPayload_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getPayload()));
};


/** @param {!(string|Uint8Array)} value */
proto.FirmwareUpload.prototype.setPayload = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.FirmwareUpload.prototype.clearPayload = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.FirmwareUpload.prototype.hasPayload = function() {
  return jspb.Message.getField(this, 2) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.DebugLinkDecision = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.DebugLinkDecision, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.DebugLinkDecision.displayName = 'proto.DebugLinkDecision';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.DebugLinkDecision.prototype.toObject = function(opt_includeInstance) {
  return proto.DebugLinkDecision.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.DebugLinkDecision} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkDecision.toObject = function(includeInstance, msg) {
  var f, obj = {
    yesNo: jspb.Message.getField(msg, 1)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.DebugLinkDecision}
 */
proto.DebugLinkDecision.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.DebugLinkDecision;
  return proto.DebugLinkDecision.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.DebugLinkDecision} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.DebugLinkDecision}
 */
proto.DebugLinkDecision.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setYesNo(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.DebugLinkDecision.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.DebugLinkDecision.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.DebugLinkDecision} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkDecision.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {boolean} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBool(
      1,
      f
    );
  }
};


/**
 * required bool yes_no = 1;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.DebugLinkDecision.prototype.getYesNo = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 1, false));
};


/** @param {boolean} value */
proto.DebugLinkDecision.prototype.setYesNo = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.DebugLinkDecision.prototype.clearYesNo = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkDecision.prototype.hasYesNo = function() {
  return jspb.Message.getField(this, 1) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.DebugLinkGetState = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.DebugLinkGetState, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.DebugLinkGetState.displayName = 'proto.DebugLinkGetState';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.DebugLinkGetState.prototype.toObject = function(opt_includeInstance) {
  return proto.DebugLinkGetState.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.DebugLinkGetState} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkGetState.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.DebugLinkGetState}
 */
proto.DebugLinkGetState.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.DebugLinkGetState;
  return proto.DebugLinkGetState.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.DebugLinkGetState} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.DebugLinkGetState}
 */
proto.DebugLinkGetState.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.DebugLinkGetState.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.DebugLinkGetState.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.DebugLinkGetState} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkGetState.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.DebugLinkState = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.DebugLinkState, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.DebugLinkState.displayName = 'proto.DebugLinkState';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.DebugLinkState.prototype.toObject = function(opt_includeInstance) {
  return proto.DebugLinkState.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.DebugLinkState} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkState.toObject = function(includeInstance, msg) {
  var f, obj = {
    layout: msg.getLayout_asB64(),
    pin: jspb.Message.getField(msg, 2),
    matrix: jspb.Message.getField(msg, 3),
    mnemonic: jspb.Message.getField(msg, 4),
    node: (f = msg.getNode()) && types_pb.HDNodeType.toObject(includeInstance, f),
    passphraseProtection: jspb.Message.getField(msg, 6),
    resetWord: jspb.Message.getField(msg, 7),
    resetEntropy: msg.getResetEntropy_asB64(),
    recoveryFakeWord: jspb.Message.getField(msg, 9),
    recoveryWordPos: jspb.Message.getField(msg, 10),
    recoveryCipher: jspb.Message.getField(msg, 11),
    recoveryAutoCompletedWord: jspb.Message.getField(msg, 12),
    firmwareHash: msg.getFirmwareHash_asB64(),
    storageHash: msg.getStorageHash_asB64()
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.DebugLinkState}
 */
proto.DebugLinkState.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.DebugLinkState;
  return proto.DebugLinkState.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.DebugLinkState} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.DebugLinkState}
 */
proto.DebugLinkState.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setLayout(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setPin(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setMatrix(value);
      break;
    case 4:
      var value = /** @type {string} */ (reader.readString());
      msg.setMnemonic(value);
      break;
    case 5:
      var value = new types_pb.HDNodeType;
      reader.readMessage(value,types_pb.HDNodeType.deserializeBinaryFromReader);
      msg.setNode(value);
      break;
    case 6:
      var value = /** @type {boolean} */ (reader.readBool());
      msg.setPassphraseProtection(value);
      break;
    case 7:
      var value = /** @type {string} */ (reader.readString());
      msg.setResetWord(value);
      break;
    case 8:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setResetEntropy(value);
      break;
    case 9:
      var value = /** @type {string} */ (reader.readString());
      msg.setRecoveryFakeWord(value);
      break;
    case 10:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setRecoveryWordPos(value);
      break;
    case 11:
      var value = /** @type {string} */ (reader.readString());
      msg.setRecoveryCipher(value);
      break;
    case 12:
      var value = /** @type {string} */ (reader.readString());
      msg.setRecoveryAutoCompletedWord(value);
      break;
    case 13:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setFirmwareHash(value);
      break;
    case 14:
      var value = /** @type {!Uint8Array} */ (reader.readBytes());
      msg.setStorageHash(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.DebugLinkState.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.DebugLinkState.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.DebugLinkState} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkState.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeBytes(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 4));
  if (f != null) {
    writer.writeString(
      4,
      f
    );
  }
  f = message.getNode();
  if (f != null) {
    writer.writeMessage(
      5,
      f,
      types_pb.HDNodeType.serializeBinaryToWriter
    );
  }
  f = /** @type {boolean} */ (jspb.Message.getField(message, 6));
  if (f != null) {
    writer.writeBool(
      6,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 7));
  if (f != null) {
    writer.writeString(
      7,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 8));
  if (f != null) {
    writer.writeBytes(
      8,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 9));
  if (f != null) {
    writer.writeString(
      9,
      f
    );
  }
  f = /** @type {number} */ (jspb.Message.getField(message, 10));
  if (f != null) {
    writer.writeUint32(
      10,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 11));
  if (f != null) {
    writer.writeString(
      11,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 12));
  if (f != null) {
    writer.writeString(
      12,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 13));
  if (f != null) {
    writer.writeBytes(
      13,
      f
    );
  }
  f = /** @type {!(string|Uint8Array)} */ (jspb.Message.getField(message, 14));
  if (f != null) {
    writer.writeBytes(
      14,
      f
    );
  }
};


/**
 * optional bytes layout = 1;
 * @return {!(string|Uint8Array)}
 */
proto.DebugLinkState.prototype.getLayout = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 1, ""));
};


/**
 * optional bytes layout = 1;
 * This is a type-conversion wrapper around `getLayout()`
 * @return {string}
 */
proto.DebugLinkState.prototype.getLayout_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getLayout()));
};


/**
 * optional bytes layout = 1;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getLayout()`
 * @return {!Uint8Array}
 */
proto.DebugLinkState.prototype.getLayout_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getLayout()));
};


/** @param {!(string|Uint8Array)} value */
proto.DebugLinkState.prototype.setLayout = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.DebugLinkState.prototype.clearLayout = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkState.prototype.hasLayout = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string pin = 2;
 * @return {string}
 */
proto.DebugLinkState.prototype.getPin = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.DebugLinkState.prototype.setPin = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.DebugLinkState.prototype.clearPin = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkState.prototype.hasPin = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional string matrix = 3;
 * @return {string}
 */
proto.DebugLinkState.prototype.getMatrix = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.DebugLinkState.prototype.setMatrix = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.DebugLinkState.prototype.clearMatrix = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkState.prototype.hasMatrix = function() {
  return jspb.Message.getField(this, 3) != null;
};


/**
 * optional string mnemonic = 4;
 * @return {string}
 */
proto.DebugLinkState.prototype.getMnemonic = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 4, ""));
};


/** @param {string} value */
proto.DebugLinkState.prototype.setMnemonic = function(value) {
  jspb.Message.setField(this, 4, value);
};


proto.DebugLinkState.prototype.clearMnemonic = function() {
  jspb.Message.setField(this, 4, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkState.prototype.hasMnemonic = function() {
  return jspb.Message.getField(this, 4) != null;
};


/**
 * optional HDNodeType node = 5;
 * @return {?proto.HDNodeType}
 */
proto.DebugLinkState.prototype.getNode = function() {
  return /** @type{?proto.HDNodeType} */ (
    jspb.Message.getWrapperField(this, types_pb.HDNodeType, 5));
};


/** @param {?proto.HDNodeType|undefined} value */
proto.DebugLinkState.prototype.setNode = function(value) {
  jspb.Message.setWrapperField(this, 5, value);
};


proto.DebugLinkState.prototype.clearNode = function() {
  this.setNode(undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkState.prototype.hasNode = function() {
  return jspb.Message.getField(this, 5) != null;
};


/**
 * optional bool passphrase_protection = 6;
 * Note that Boolean fields may be set to 0/1 when serialized from a Java server.
 * You should avoid comparisons like {@code val === true/false} in those cases.
 * @return {boolean}
 */
proto.DebugLinkState.prototype.getPassphraseProtection = function() {
  return /** @type {boolean} */ (jspb.Message.getFieldWithDefault(this, 6, false));
};


/** @param {boolean} value */
proto.DebugLinkState.prototype.setPassphraseProtection = function(value) {
  jspb.Message.setField(this, 6, value);
};


proto.DebugLinkState.prototype.clearPassphraseProtection = function() {
  jspb.Message.setField(this, 6, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkState.prototype.hasPassphraseProtection = function() {
  return jspb.Message.getField(this, 6) != null;
};


/**
 * optional string reset_word = 7;
 * @return {string}
 */
proto.DebugLinkState.prototype.getResetWord = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 7, ""));
};


/** @param {string} value */
proto.DebugLinkState.prototype.setResetWord = function(value) {
  jspb.Message.setField(this, 7, value);
};


proto.DebugLinkState.prototype.clearResetWord = function() {
  jspb.Message.setField(this, 7, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkState.prototype.hasResetWord = function() {
  return jspb.Message.getField(this, 7) != null;
};


/**
 * optional bytes reset_entropy = 8;
 * @return {!(string|Uint8Array)}
 */
proto.DebugLinkState.prototype.getResetEntropy = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 8, ""));
};


/**
 * optional bytes reset_entropy = 8;
 * This is a type-conversion wrapper around `getResetEntropy()`
 * @return {string}
 */
proto.DebugLinkState.prototype.getResetEntropy_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getResetEntropy()));
};


/**
 * optional bytes reset_entropy = 8;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getResetEntropy()`
 * @return {!Uint8Array}
 */
proto.DebugLinkState.prototype.getResetEntropy_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getResetEntropy()));
};


/** @param {!(string|Uint8Array)} value */
proto.DebugLinkState.prototype.setResetEntropy = function(value) {
  jspb.Message.setField(this, 8, value);
};


proto.DebugLinkState.prototype.clearResetEntropy = function() {
  jspb.Message.setField(this, 8, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkState.prototype.hasResetEntropy = function() {
  return jspb.Message.getField(this, 8) != null;
};


/**
 * optional string recovery_fake_word = 9;
 * @return {string}
 */
proto.DebugLinkState.prototype.getRecoveryFakeWord = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 9, ""));
};


/** @param {string} value */
proto.DebugLinkState.prototype.setRecoveryFakeWord = function(value) {
  jspb.Message.setField(this, 9, value);
};


proto.DebugLinkState.prototype.clearRecoveryFakeWord = function() {
  jspb.Message.setField(this, 9, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkState.prototype.hasRecoveryFakeWord = function() {
  return jspb.Message.getField(this, 9) != null;
};


/**
 * optional uint32 recovery_word_pos = 10;
 * @return {number}
 */
proto.DebugLinkState.prototype.getRecoveryWordPos = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 10, 0));
};


/** @param {number} value */
proto.DebugLinkState.prototype.setRecoveryWordPos = function(value) {
  jspb.Message.setField(this, 10, value);
};


proto.DebugLinkState.prototype.clearRecoveryWordPos = function() {
  jspb.Message.setField(this, 10, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkState.prototype.hasRecoveryWordPos = function() {
  return jspb.Message.getField(this, 10) != null;
};


/**
 * optional string recovery_cipher = 11;
 * @return {string}
 */
proto.DebugLinkState.prototype.getRecoveryCipher = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 11, ""));
};


/** @param {string} value */
proto.DebugLinkState.prototype.setRecoveryCipher = function(value) {
  jspb.Message.setField(this, 11, value);
};


proto.DebugLinkState.prototype.clearRecoveryCipher = function() {
  jspb.Message.setField(this, 11, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkState.prototype.hasRecoveryCipher = function() {
  return jspb.Message.getField(this, 11) != null;
};


/**
 * optional string recovery_auto_completed_word = 12;
 * @return {string}
 */
proto.DebugLinkState.prototype.getRecoveryAutoCompletedWord = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 12, ""));
};


/** @param {string} value */
proto.DebugLinkState.prototype.setRecoveryAutoCompletedWord = function(value) {
  jspb.Message.setField(this, 12, value);
};


proto.DebugLinkState.prototype.clearRecoveryAutoCompletedWord = function() {
  jspb.Message.setField(this, 12, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkState.prototype.hasRecoveryAutoCompletedWord = function() {
  return jspb.Message.getField(this, 12) != null;
};


/**
 * optional bytes firmware_hash = 13;
 * @return {!(string|Uint8Array)}
 */
proto.DebugLinkState.prototype.getFirmwareHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 13, ""));
};


/**
 * optional bytes firmware_hash = 13;
 * This is a type-conversion wrapper around `getFirmwareHash()`
 * @return {string}
 */
proto.DebugLinkState.prototype.getFirmwareHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getFirmwareHash()));
};


/**
 * optional bytes firmware_hash = 13;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getFirmwareHash()`
 * @return {!Uint8Array}
 */
proto.DebugLinkState.prototype.getFirmwareHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getFirmwareHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.DebugLinkState.prototype.setFirmwareHash = function(value) {
  jspb.Message.setField(this, 13, value);
};


proto.DebugLinkState.prototype.clearFirmwareHash = function() {
  jspb.Message.setField(this, 13, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkState.prototype.hasFirmwareHash = function() {
  return jspb.Message.getField(this, 13) != null;
};


/**
 * optional bytes storage_hash = 14;
 * @return {!(string|Uint8Array)}
 */
proto.DebugLinkState.prototype.getStorageHash = function() {
  return /** @type {!(string|Uint8Array)} */ (jspb.Message.getFieldWithDefault(this, 14, ""));
};


/**
 * optional bytes storage_hash = 14;
 * This is a type-conversion wrapper around `getStorageHash()`
 * @return {string}
 */
proto.DebugLinkState.prototype.getStorageHash_asB64 = function() {
  return /** @type {string} */ (jspb.Message.bytesAsB64(
      this.getStorageHash()));
};


/**
 * optional bytes storage_hash = 14;
 * Note that Uint8Array is not supported on all browsers.
 * @see http://caniuse.com/Uint8Array
 * This is a type-conversion wrapper around `getStorageHash()`
 * @return {!Uint8Array}
 */
proto.DebugLinkState.prototype.getStorageHash_asU8 = function() {
  return /** @type {!Uint8Array} */ (jspb.Message.bytesAsU8(
      this.getStorageHash()));
};


/** @param {!(string|Uint8Array)} value */
proto.DebugLinkState.prototype.setStorageHash = function(value) {
  jspb.Message.setField(this, 14, value);
};


proto.DebugLinkState.prototype.clearStorageHash = function() {
  jspb.Message.setField(this, 14, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkState.prototype.hasStorageHash = function() {
  return jspb.Message.getField(this, 14) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.DebugLinkStop = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.DebugLinkStop, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.DebugLinkStop.displayName = 'proto.DebugLinkStop';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.DebugLinkStop.prototype.toObject = function(opt_includeInstance) {
  return proto.DebugLinkStop.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.DebugLinkStop} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkStop.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.DebugLinkStop}
 */
proto.DebugLinkStop.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.DebugLinkStop;
  return proto.DebugLinkStop.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.DebugLinkStop} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.DebugLinkStop}
 */
proto.DebugLinkStop.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.DebugLinkStop.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.DebugLinkStop.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.DebugLinkStop} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkStop.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.DebugLinkLog = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.DebugLinkLog, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.DebugLinkLog.displayName = 'proto.DebugLinkLog';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.DebugLinkLog.prototype.toObject = function(opt_includeInstance) {
  return proto.DebugLinkLog.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.DebugLinkLog} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkLog.toObject = function(includeInstance, msg) {
  var f, obj = {
    level: jspb.Message.getField(msg, 1),
    bucket: jspb.Message.getField(msg, 2),
    text: jspb.Message.getField(msg, 3)
  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.DebugLinkLog}
 */
proto.DebugLinkLog.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.DebugLinkLog;
  return proto.DebugLinkLog.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.DebugLinkLog} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.DebugLinkLog}
 */
proto.DebugLinkLog.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    case 1:
      var value = /** @type {number} */ (reader.readUint32());
      msg.setLevel(value);
      break;
    case 2:
      var value = /** @type {string} */ (reader.readString());
      msg.setBucket(value);
      break;
    case 3:
      var value = /** @type {string} */ (reader.readString());
      msg.setText(value);
      break;
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.DebugLinkLog.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.DebugLinkLog.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.DebugLinkLog} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkLog.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
  f = /** @type {number} */ (jspb.Message.getField(message, 1));
  if (f != null) {
    writer.writeUint32(
      1,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 2));
  if (f != null) {
    writer.writeString(
      2,
      f
    );
  }
  f = /** @type {string} */ (jspb.Message.getField(message, 3));
  if (f != null) {
    writer.writeString(
      3,
      f
    );
  }
};


/**
 * optional uint32 level = 1;
 * @return {number}
 */
proto.DebugLinkLog.prototype.getLevel = function() {
  return /** @type {number} */ (jspb.Message.getFieldWithDefault(this, 1, 0));
};


/** @param {number} value */
proto.DebugLinkLog.prototype.setLevel = function(value) {
  jspb.Message.setField(this, 1, value);
};


proto.DebugLinkLog.prototype.clearLevel = function() {
  jspb.Message.setField(this, 1, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkLog.prototype.hasLevel = function() {
  return jspb.Message.getField(this, 1) != null;
};


/**
 * optional string bucket = 2;
 * @return {string}
 */
proto.DebugLinkLog.prototype.getBucket = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 2, ""));
};


/** @param {string} value */
proto.DebugLinkLog.prototype.setBucket = function(value) {
  jspb.Message.setField(this, 2, value);
};


proto.DebugLinkLog.prototype.clearBucket = function() {
  jspb.Message.setField(this, 2, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkLog.prototype.hasBucket = function() {
  return jspb.Message.getField(this, 2) != null;
};


/**
 * optional string text = 3;
 * @return {string}
 */
proto.DebugLinkLog.prototype.getText = function() {
  return /** @type {string} */ (jspb.Message.getFieldWithDefault(this, 3, ""));
};


/** @param {string} value */
proto.DebugLinkLog.prototype.setText = function(value) {
  jspb.Message.setField(this, 3, value);
};


proto.DebugLinkLog.prototype.clearText = function() {
  jspb.Message.setField(this, 3, undefined);
};


/**
 * Returns whether this field is set.
 * @return {!boolean}
 */
proto.DebugLinkLog.prototype.hasText = function() {
  return jspb.Message.getField(this, 3) != null;
};



/**
 * Generated by JsPbCodeGenerator.
 * @param {Array=} opt_data Optional initial data array, typically from a
 * server response, or constructed directly in Javascript. The array is used
 * in place and becomes part of the constructed object. It is not cloned.
 * If no data is provided, the constructed object will be empty, but still
 * valid.
 * @extends {jspb.Message}
 * @constructor
 */
proto.DebugLinkFillConfig = function(opt_data) {
  jspb.Message.initialize(this, opt_data, 0, -1, null, null);
};
goog.inherits(proto.DebugLinkFillConfig, jspb.Message);
if (goog.DEBUG && !COMPILED) {
  proto.DebugLinkFillConfig.displayName = 'proto.DebugLinkFillConfig';
}


if (jspb.Message.GENERATE_TO_OBJECT) {
/**
 * Creates an object representation of this proto suitable for use in Soy templates.
 * Field names that are reserved in JavaScript and will be renamed to pb_name.
 * To access a reserved field use, foo.pb_<name>, eg, foo.pb_default.
 * For the list of reserved names please see:
 *     com.google.apps.jspb.JsClassTemplate.JS_RESERVED_WORDS.
 * @param {boolean=} opt_includeInstance Whether to include the JSPB instance
 *     for transitional soy proto support: http://goto/soy-param-migration
 * @return {!Object}
 */
proto.DebugLinkFillConfig.prototype.toObject = function(opt_includeInstance) {
  return proto.DebugLinkFillConfig.toObject(opt_includeInstance, this);
};


/**
 * Static version of the {@see toObject} method.
 * @param {boolean|undefined} includeInstance Whether to include the JSPB
 *     instance for transitional soy proto support:
 *     http://goto/soy-param-migration
 * @param {!proto.DebugLinkFillConfig} msg The msg instance to transform.
 * @return {!Object}
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkFillConfig.toObject = function(includeInstance, msg) {
  var f, obj = {

  };

  if (includeInstance) {
    obj.$jspbMessageInstance = msg;
  }
  return obj;
};
}


/**
 * Deserializes binary data (in protobuf wire format).
 * @param {jspb.ByteSource} bytes The bytes to deserialize.
 * @return {!proto.DebugLinkFillConfig}
 */
proto.DebugLinkFillConfig.deserializeBinary = function(bytes) {
  var reader = new jspb.BinaryReader(bytes);
  var msg = new proto.DebugLinkFillConfig;
  return proto.DebugLinkFillConfig.deserializeBinaryFromReader(msg, reader);
};


/**
 * Deserializes binary data (in protobuf wire format) from the
 * given reader into the given message object.
 * @param {!proto.DebugLinkFillConfig} msg The message object to deserialize into.
 * @param {!jspb.BinaryReader} reader The BinaryReader to use.
 * @return {!proto.DebugLinkFillConfig}
 */
proto.DebugLinkFillConfig.deserializeBinaryFromReader = function(msg, reader) {
  while (reader.nextField()) {
    if (reader.isEndGroup()) {
      break;
    }
    var field = reader.getFieldNumber();
    switch (field) {
    default:
      reader.skipField();
      break;
    }
  }
  return msg;
};


/**
 * Serializes the message to binary data (in protobuf wire format).
 * @return {!Uint8Array}
 */
proto.DebugLinkFillConfig.prototype.serializeBinary = function() {
  var writer = new jspb.BinaryWriter();
  proto.DebugLinkFillConfig.serializeBinaryToWriter(this, writer);
  return writer.getResultBuffer();
};


/**
 * Serializes the given message to binary data (in protobuf wire
 * format), writing to the given BinaryWriter.
 * @param {!proto.DebugLinkFillConfig} message
 * @param {!jspb.BinaryWriter} writer
 * @suppress {unusedLocalVariables} f is only used for nested messages
 */
proto.DebugLinkFillConfig.serializeBinaryToWriter = function(message, writer) {
  var f = undefined;
};


/**
 * @enum {number}
 */
proto.MessageType = {
  MESSAGETYPE_INITIALIZE: 0,
  MESSAGETYPE_PING: 1,
  MESSAGETYPE_SUCCESS: 2,
  MESSAGETYPE_FAILURE: 3,
  MESSAGETYPE_CHANGEPIN: 4,
  MESSAGETYPE_WIPEDEVICE: 5,
  MESSAGETYPE_FIRMWAREERASE: 6,
  MESSAGETYPE_FIRMWAREUPLOAD: 7,
  MESSAGETYPE_GETENTROPY: 9,
  MESSAGETYPE_ENTROPY: 10,
  MESSAGETYPE_GETPUBLICKEY: 11,
  MESSAGETYPE_PUBLICKEY: 12,
  MESSAGETYPE_LOADDEVICE: 13,
  MESSAGETYPE_RESETDEVICE: 14,
  MESSAGETYPE_SIGNTX: 15,
  MESSAGETYPE_FEATURES: 17,
  MESSAGETYPE_PINMATRIXREQUEST: 18,
  MESSAGETYPE_PINMATRIXACK: 19,
  MESSAGETYPE_CANCEL: 20,
  MESSAGETYPE_TXREQUEST: 21,
  MESSAGETYPE_TXACK: 22,
  MESSAGETYPE_CIPHERKEYVALUE: 23,
  MESSAGETYPE_CLEARSESSION: 24,
  MESSAGETYPE_APPLYSETTINGS: 25,
  MESSAGETYPE_BUTTONREQUEST: 26,
  MESSAGETYPE_BUTTONACK: 27,
  MESSAGETYPE_GETADDRESS: 29,
  MESSAGETYPE_ADDRESS: 30,
  MESSAGETYPE_ENTROPYREQUEST: 35,
  MESSAGETYPE_ENTROPYACK: 36,
  MESSAGETYPE_SIGNMESSAGE: 38,
  MESSAGETYPE_VERIFYMESSAGE: 39,
  MESSAGETYPE_MESSAGESIGNATURE: 40,
  MESSAGETYPE_PASSPHRASEREQUEST: 41,
  MESSAGETYPE_PASSPHRASEACK: 42,
  MESSAGETYPE_ESTIMATETXSIZE: 43,
  MESSAGETYPE_TXSIZE: 44,
  MESSAGETYPE_RECOVERYDEVICE: 45,
  MESSAGETYPE_WORDREQUEST: 46,
  MESSAGETYPE_WORDACK: 47,
  MESSAGETYPE_CIPHEREDKEYVALUE: 48,
  MESSAGETYPE_ENCRYPTMESSAGE: 49,
  MESSAGETYPE_ENCRYPTEDMESSAGE: 50,
  MESSAGETYPE_DECRYPTMESSAGE: 51,
  MESSAGETYPE_DECRYPTEDMESSAGE: 52,
  MESSAGETYPE_SIGNIDENTITY: 53,
  MESSAGETYPE_SIGNEDIDENTITY: 54,
  MESSAGETYPE_GETFEATURES: 55,
  MESSAGETYPE_ETHEREUMGETADDRESS: 56,
  MESSAGETYPE_ETHEREUMADDRESS: 57,
  MESSAGETYPE_ETHEREUMSIGNTX: 58,
  MESSAGETYPE_ETHEREUMTXREQUEST: 59,
  MESSAGETYPE_ETHEREUMTXACK: 60,
  MESSAGETYPE_CHARACTERREQUEST: 80,
  MESSAGETYPE_CHARACTERACK: 81,
  MESSAGETYPE_RAWTXACK: 82,
  MESSAGETYPE_APPLYPOLICIES: 83,
  MESSAGETYPE_FLASHHASH: 84,
  MESSAGETYPE_FLASHWRITE: 85,
  MESSAGETYPE_FLASHHASHRESPONSE: 86,
  MESSAGETYPE_DEBUGLINKFLASHDUMP: 87,
  MESSAGETYPE_DEBUGLINKFLASHDUMPRESPONSE: 88,
  MESSAGETYPE_SOFTRESET: 89,
  MESSAGETYPE_DEBUGLINKDECISION: 100,
  MESSAGETYPE_DEBUGLINKGETSTATE: 101,
  MESSAGETYPE_DEBUGLINKSTATE: 102,
  MESSAGETYPE_DEBUGLINKSTOP: 103,
  MESSAGETYPE_DEBUGLINKLOG: 104,
  MESSAGETYPE_DEBUGLINKFILLCONFIG: 105,
  MESSAGETYPE_GETCOINTABLE: 106,
  MESSAGETYPE_COINTABLE: 107,
  MESSAGETYPE_ETHEREUMSIGNMESSAGE: 108,
  MESSAGETYPE_ETHEREUMVERIFYMESSAGE: 109,
  MESSAGETYPE_ETHEREUMMESSAGESIGNATURE: 110,
  MESSAGETYPE_EOSGETPUBLICKEY: 600,
  MESSAGETYPE_EOSPUBLICKEY: 601,
  MESSAGETYPE_EOSSIGNTX: 602,
  MESSAGETYPE_EOSTXACTIONREQUEST: 603,
  MESSAGETYPE_EOSTXACTIONACK: 604,
  MESSAGETYPE_EOSSIGNEDTX: 605
};

goog.object.extend(exports, proto);
